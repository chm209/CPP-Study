# C++ 코드의 재활용

C++가 추구하는 중요한 목표 중의 하나가 코드의 재활용성을 높이는것

public 상속은 한 가지 방법일뿐 이번 장에서는 다른 방법들을 공부한다.

1. 컨테인먼트, 컴포지션, 레이어링: 다른 클래스에 속하는 객체를 클래스 멤버로 사용하는 것 (has-a 관계)
2. private 상속 or protected 상속 (has-a 관계)
3. 클래스 템플릿을 사용: 클래스를 포괄적으로 정의 가능, 그 템플릿을 사용하여 특정한 데이터형에 맞게 정의된 특정한 클래스를 생성할 수 있다.

> has-a 관계: 새로운 클래스가 다른 클래스의 객체를 포함하는 관계

---

## 객체 멤버를 가지는 클래스

템플릿 측면에서 보면, 객체를 선언할 때 구체적인 데이터형을 지정해야 한다.

그렇게 하려면 객체를 선언할 때 원하는 데이터형이 들어 있는 각괄호 앞에 식별자를 붙여야한다.

1. valarray &lt;int> q_values; -> int형의 배열
2. valarray &lt;double> weights; -> double형의 배열

클래스 측면에서 보면 valarray 객체를 사용하기 위해서는 클래스 생성자와 그외 클래스 메서드들에 관해 어떤 것을 알 필요가 있다.

1. valarray &lt;double> v1; -> double형의 배열, 크기 0
2. valarray &lt;int> v2(8); -> int형의 배열, 8개짜리 배열
3. valarray &lt;int> v3(10, 8); -> int형의 배열, 8개짜리 배열, 각각 10으로 설정
4. valarray &lt;double> v4(gpa, 4); -> double형 원소 4개짜리 배열, gpa의 첫 4개의 원소로 초기화

### Student 클래스 설계

학생은 이름이 아니고 성적표도 아니기 때문에 is-a 관계인 public 상속은 적합하지 않다.

학생은 이름과 성적표를 가지기 때문에 has-a 관계로 설계하는게 적합하다.

C++에서 has-a 관계를 모델링하는 일반적인 테크닉은, ```컴포지션(컨테인먼트)```을 사용하는 것이다.

즉, 다른 클래스의 객체들을 멤버로 가지는 클래스를 만드는 것이다.

예를 들면, 아래와 같이 클래스를 시작할 수 있다.

``` cpp
class Student
{
    private:
        string name;
        valarray<double> score;
}
```

보통 그 클래스는 데이터 멤버들을 private으로 선언한다.

##### 인터페이스의 구현

public 상속에서, 클래스는 인터페이스와 구현을 상속한다. 반면 컨테인먼트에서는 어떤 클래스가 인터페이스 없이 구현을 획득한다.

##### 멤버 초기자 리스트의 초기화 순서

하나 이상의 항목들을 초기화하는 멤버 초기자 리스트를 사용한다면, 그 항목들은 멤버 초기자 리스트에 나타나는 순서대로 초기화되지 않고, 그들이 선언된 순서대로 초기화된다.

##### 헬퍼 메서드

보조적인 역할로 사용되며, 있어도 그만 없어도 그만이라고 한다.

---

## private 상속

has-a 관계를 구현하는 제2의 수단

1. private 상속에서는, 기초 클래스의 public 멤버와 protected 멤버가 파생 클래스의 private 멤버가 된다.

> public 상속에서는 기초 클래스의 public 메서드가 파생 클래스의 public 메서드가 된다. 다시말해 파생 클래스는 기초 클래스의 인터페이스를 상속한다.

> 그러나 private 상속에서는 파생 클래스가 기초 클래스의 인터페이스를 상속하지 않는다.

2. 클래스가 구현을 상속한다.
3. 컨테인먼트는 객체를 이름이 있는 멤버 객체로 클래스에 추가한다. 반면 private 상속은, 객체를 이름이 없는 상속된 객체로 클래스에 추가한다.
4. private 상속은 컨테인먼트와 동일한 기능을 제공한다. 즉 구현은 획득하지만 인터페이스는 획득하지 않는다.

##### 다중 상속(MI): 기초 클래스가 하나 이상일 경우에 다중 상속이라고 부름, 그러나 문제가 많아 (특히 publuc MI) 업계에서는 사용하지 않고 인터페이스 포함 + 팩토리 패턴을 사용한다고 한다

예제 코드는 생략한다. 예시를 보면 알겠지만 기존에 작성 했던 코드에서 일부분만 수정했다.

``` cpp
1. 상속을 할때 디폴트 키워드는 private다. 하여 키워드를 생략하면 자동으로 private 상속이 되는데, 식별자를 써주는게 좋다.

2. 이 예제의 경우 private 다중 상속을 해야한다.

class Student : private std::string, private std::valarray<double>
{ ... }

3. private 상속은 기초 클래스 메서드를 파생 클래스 메서드의 안에서만 사용할 수 있도록 제한한다. 그러나 기초 클래스 기능을 public으로 사용하고 싶을때는 범위 결정 연산자로 호출할 수 있다.

double Student::Average() const
{ if(ArrayDb::size() > 0) ... }
```

##### 컨테인먼트와 private 상속

컨테인먼트와 private 상속 둘 중 어느 하나를 사용하여 has-a 관계를 모델링할 수 있다면, 어느 것을 사용해야 할까?

대부분의 개발자들은 컨테인먼트를 선호한다.

1. 사용하기 쉽다

> 클래스 선언을 들여다보고 내포된 클래스를 나타내는 객체가 명시적으로 이름이 지정되어 있고, 프로그램에서 이들 객체를 이름을 사용하여 참조할 수 있다.

2. 하나 이상의 기초 클래스로부터 클래스를 상속할 때, 상속이 문제를 일으킬 수 있기 때문이다.

그러나 private 상속은 컨티엔먼트가 제공하는 것 이상의 기능을 제공한다.

private 상속을 사용해야 하는 다른 상황은, 가상 함수를 다시 정의할 필요가 있을 때이다.

##### protected 상속

protected 상속은 private 상속의 변종이다. protected 상속은 기초 클래스를 나열할 때 키워드 protected를 사용한다.

protected 상속에서는 기초 클래스의 public 멤버와 protected 멤버가 파생 클래스의 protected 멤버가 된다.

private 상속과 마찬가지로 기초 클래스의 인터페이스를 파생 클래스에서 사용할 수 있지만, 바깥 세계에서는 사용할 수 없다.

``` c++
class Student : protected std::string, protected std::valarray<double>
{
    ...
};
```

protected 상속과 private 상속의 차이점은 파생 클래스로부터 또 다른 클래스를 파생시킬때 들어난다.

##### using을 사용하여 접근 다시 정의하기

protected 파생이나 private 파생을 사용할 때, 기초 클래스의 public 멤버들은 protected 멤버 또는 private 멤버가 된다.

어떤 특정 기초 클래스 메서드를 파생 클래스에서 public으로 사용할 수 있게 하고 싶다고 가정하자.

1. 기초 클래스 메서드를 사용하는 파생 클래스 메서드를 정의하는 방법

``` cpp
double Student::sum() const
{
    return std::valarray<double>::sum();
    // private로 상속된 메서드
}
```

2. 하나의 함수 호출을 다른 함수 안에 넣을 수 있는 방법. using 선언을 사용하여, 파생 클래스에서 사용할 특정 기초 클래스 멤버를 지정하는 것이다. 선언에서 작성할 수 있다.

``` cpp
class Student : private std::string, private std::valarray<double>
{
    ...
public:
    using std::valarray<double>::min;
    using std::valarray<double>::max;
};
```

3. private으로 파생된 클래스에 기초 클래스 메서드들을 다시 선언하는 방법 (사용하지 말것 -> using을 사용하는 이유를 퇴색시킨다.)

---

## 다중상속 (MI)

문제가 많아서 업계에서는 사용하지 않는다. 인터페이스 포함 + 팩토리 패턴을 주로 사용한다고 함

#### 예제 코드는 작성하지 않고 책으로만 보겠다

##### 가상 기초 클래스

하나의 공통 조상을 공유하는 여려 개의 기초 클래스부로부터 공통 조상의 유일 객체를 상속하는 방식으로 객체를 파생시키는 것을 허용한다.

아래의 코드는 클래스 선언에 키워드 virtual을 사용하여 Worker를 Singer와 Waiter의 가상 기초 클래스로 만든다. (virtual과 public이 나타내는 순서는 아무래도 좋다.)

``` cpp
class Singer : virtual public Worker {...};
class Waiter : public virtual Worker {...};
```

이렇게 하면 SingingWaiter를 전처럼 정의할 수 있다.

``` cpp
class SingingWaiter : public Singer, public Waiter
```

1032 페이지 내용 필독 !

1. 클래스가 간접적인 가상 기초 클래스를 가진다면, 가상 기초 클래스의 디폴트 생성자가 필요한 겨우를 제외하고, 그 클래스의 생성자는 가상 기초 클래스의 생성자를 명시적으로 호출해야 한다.

2. 다중 상속은 모호한 함수 호출을 일으킬 수 있다.

### ```다중 상속에 관한 문제```

1047p 확인

1. 가상 기초 클래스와 가상이 아닌 기초 클래스의 혼합

2. 가상 기초 클래스와 비교 우위

### 다중 상속 요약

어지간해서는 절대 사용하지 말자.

---

## 클래스 템플릿

상속과 컨테인먼트가 코드를 재활용하고 싶을 때 항상 해결책이 되는 것은 아니다.

10장 stack 클래스의 저장되는 객체만 다르고 코드는 동일한 부분은 typedef를 사용한다.

이 접근 방식에는 두가지 단점이 있다.

1. 데이터형을 변경할 때마다 헤더 파일을 수정해야 한다.
2. 프로그램당 한종류의 스택만 생성할 때 이 테크닉을 사용할 수 있다. 즉 typedef로는 동시에 두가지 데이터형을 나타낼 수 없다.

템플릿은 매개변수화 되는 데이터형을 제공한다.

즉 템플릿은 클래스나 함수 설계도에 데이터형 이름을 매개변수로 넘겨줄 수 있다.

```cpp
template <class Type>
/*
class는 데이터형을 값으로 받ㅇ아들이는 어떤 변수의 데이터형 이름의 역할을 하고, type은 그 변수의 이름을 나타낸다고 생각할 수 있다.
여기서 class를 사용하는 것은, Type이  반드시 클래스여야 한다는 것을 의미하지 않는다.
단지 Type이 사용될 때 실제 데이터형으로 대체되는 포괄 데이터형의 지정자 역할을 한다는 뜻이다.
*/

// 최신 컴파일러에서는 혼동을 막기 위해 class 대신에 typename을 사용할 수 있다.
template <typename Type>


// typedef 식별자인 Item을 Type으로 대체해야 한다.
Item items[MAX];
Type items[MAX];

// 오리지널 클래스의 클래스 메서드들을 템플릿 멤버 함수로 대체할 수 있다.
// 각각의 함수 머리에 동일한 템플릿 표시를 앞세운다. template <class Type>

// 마찬가지로 typedef 식별자인 Item을 포괄적인 데이터형 이름 Type을 대체해야 한다.
// 주의할점은 클래스 제한자를 Stack:: 에서 Stack<Type>:: 으로 변경해야 한다는 것이다.
bool Stack::push(const Item & item)
{ ... }
//를 아래와 같이 변경한다.
template <class Type> // or template <typename Type>
bool Stack<Type>::push (const Type & item)
{ ... }

// 클래스 선언 안에서 메서드를 정의한다면(인라인 정의), 템플릿 제한자와 클래스 제한자를 생략할 수 있다.
```

##### stacktp.hpp

클래스 템플릿과 멤버 함수 템플릿들이 결합된 것이다.

중요한점은 이 템플릿들이 클래스와 멤버 함수 정의가 아니라는 사실을 깨닫는 것이다.

이 템플릿들은 클래스와 멤버 함수 정의를 생성하는 방법을 컴파일러에게 알려주는 지시문이다.

### ``` 포인터들의 스택을 잘못 사용하는 경우 [1059p ~ 1060p] ```

예제 코드를 포인터들의 스택을 사용할 수 있도록 개조하되, 간단한 결함이 있는 3가지 시도를 공부한다.

이 잘못된 시도들은, 템플릿을 무턱대고 사용할 것이 아니라 템플릿의 설계를 항상 마음속에 두어야 한다는 교훈을 알려준다.

잘못된 예제 3가지 모두 완벽하게 유효한 Stack\<Type> 템플릿의 발효로 시작된다.

> Stack\<char *> st;

```cpp
// 버전1
string po;
// 위 코드를 아래 구문으로 대체한다.
char * po;

// 이는 string 객체 대신에 char형을 지시하는 포인터를 사용하여 키보드 입력을 받아들이겠다는 생각이다.
// 포인터의 단순한 생성은 입력 문자열들의 저장 공간을 생성하지 않기 때문에, 이와 같은 접근은 즉시 실패한다.
```

``` cpp
// 버전 2
string po;
// 위 코드를 아래 구문으로 대체한다.
char po[40];

// 이것은 입력 문자열을 저장하기 위한 공간을 대입한다. 게다가 po는 char * 형이므로 스택에 넣을 수 있다.
// 그러나 배열은 pop() 메서드에서 약속한 가정과 기본적으로 불화를 일으킨다.
// 첫째. 참조 변수 item은 배열 이름이 아니라 어떤 종류의 Lvalue를 참조해야 한다.
// 둘째. 이 코드는 item에 대입할 수 있다고 가정한다. item이 어떤 배열을 참조할 수 있을지라도, 배열 이름에는 대입할 수 없다.
```

``` cpp
// 버전3
string po;
// 위 코드를 아래 구문으로 대체한다.
char* po = new char[40];

// 이것은 입력 문자열을 저장하기 위한 공간을 대입한다. 게다가 po가 변수이므로 pop()의 코드와 불화를 일으키지 않는다.
// 그러나 가장 근본적인 문제에 부닥친다. po 변수는 하나밖에 없고, 그것은 항상 같은 메모리 위치를 지시한다.
// 그 메모리 내용은 새로운 문자열을 읽을 때마다 바뀐다.
// 그러나 푸시 연산은 매번 정확히 동일한 주소를 스택에 넣는다. 그래서 스택을 팝하면 항상 동일한 주소를 얻는다.
// 그리고 그것은 메모리에 마지막으로 읽어들인 문자열을 항상 참조한다.
// 특히 그와 같은 스택은 새 문자열이 들어올 때마다 이들을 개별적으로 저장하지 않으므로, 유용한 용도로 사용할 수가 없다.
```

### ``` 포인터들의 스택을 바르게 사용하는 경우 [1060p ~ 1066p] ```

포인터들의 스택을 사용하는 한 가지 방법은, 호출한 프로그램이 포인터들의 배열을 제공하는 것이다.

그 포인터들의 배열에서 각각의 포인터는 서로 다른 문자열을 지시한다.

이러한 포인터들을 스택에 넣는 것은, 각각의 포인터가 서로 다른 문자열을 참조하기 때문에 논리적으로 틀리지 않는다.

hpp 예제 코드에서 ```대입 연산자 함수의 리턴형``` Stack에 대한 참조로 선언하고, 실제 템플릿 함수 정의에서는 Stack\<Type>에 대한 참조로 선언한 것에 주목하라.

Stack은 Stack\<Type>의 약식 표기이고, 그 클래스 사용 범위 안에서만 사용할 수 있다.

그러나 리턴형을 인식할 때와 사용 범위 결정 연산자를 사용할 때와 같이, 그 클래스 바깥에서는 완전한 형식인 Stack\<Type>을 사용해야 한다.

#### ``` 코드 분석 ```

예제 코드의 문자열들은 결코 이동하지 않는다.

하나의 문자열을 스택에 푸시하면, 실제로는 기존의 문자열을 지시하는 새로운 포인터가 생성된다.

즉, 그것은 기존 문자열의 주소를 값으로 가지는 포인터를 생성한다.

하나의 문자열을 스택에서 팝 하면, 그 주소 값이 out 배열에 복사된다.

이 코드는 포인터들의 배열이 하나의 문자열 상수 집합으로 초기화되기 때문에, const char *를 데이터형으로 사용한다.

스택 소멸자는 그 문자열들에 아무런 영향도 미치지 않는다.

클래스 생성자는 new를 사용하여 포인터들을 저장할 배열을 생성한다.

클래스 소멸자는 그 배열을 삭제한다. 그러나 그 배열의 원소들이 지시하는 문자열들은 삭제하지 않는다.