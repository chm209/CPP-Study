# C++ 코드의 재활용

C++가 추구하는 중요한 목표 중의 하나가 코드의 재활용성을 높이는것

public 상속은 한 가지 방법일뿐 이번 장에서는 다른 방법들을 공부한다.

1. 컨테인먼트, 컴포지션, 레이어링: 다른 클래스에 속하는 객체를 클래스 멤버로 사용하는 것 (has-a 관계)
2. private 상속 or protected 상속 (has-a 관계)
3. 클래스 템플릿을 사용: 클래스를 포괄적으로 정의 가능, 그 템플릿을 사용하여 특정한 데이터형에 맞게 정의된 특정한 클래스를 생성할 수 있다.

> has-a 관계: 새로운 클래스가 다른 클래스의 객체를 포함하는 관계

---

## 객체 멤버를 가지는 클래스

템플릿 측면에서 보면, 객체를 선언할 때 구체적인 데이터형을 지정해야 한다.

그렇게 하려면 객체를 선언할 때 원하는 데이터형이 들어 있는 각괄호 앞에 식별자를 붙여야한다.

1. valarray &lt;int> q_values; -> int형의 배열
2. valarray &lt;double> weights; -> double형의 배열

클래스 측면에서 보면 valarray 객체를 사용하기 위해서는 클래스 생성자와 그외 클래스 메서드들에 관해 어떤 것을 알 필요가 있다.

1. valarray &lt;double> v1; -> double형의 배열, 크기 0
2. valarray &lt;int> v2(8); -> int형의 배열, 8개짜리 배열
3. valarray &lt;int> v3(10, 8); -> int형의 배열, 8개짜리 배열, 각각 10으로 설정
4. valarray &lt;double> v4(gpa, 4); -> double형 원소 4개짜리 배열, gpa의 첫 4개의 원소로 초기화

### Student 클래스 설계

학생은 이름이 아니고 성적표도 아니기 때문에 is-a 관계인 public 상속은 적합하지 않다.

학생은 이름과 성적표를 가지기 때문에 has-a 관계로 설계하는게 적합하다.

C++에서 has-a 관계를 모델링하는 일반적인 테크닉은, ```컴포지션(컨테인먼트)```을 사용하는 것이다.

즉, 다른 클래스의 객체들을 멤버로 가지는 클래스를 만드는 것이다.

예를 들면, 아래와 같이 클래스를 시작할 수 있다.

``` cpp
class Student
{
    private:
        string name;
        valarray<double> score;
}
```

보통 그 클래스는 데이터 멤버들을 private으로 선언한다.

##### 인터페이스의 구현

public 상속에서, 클래스는 인터페이스와 구현을 상속한다. 반면 컨테인먼트에서는 어떤 클래스가 인터페이스 없이 구현을 획득한다.

##### 멤버 초기자 리스트의 초기화 순서

하나 이상의 항목들을 초기화하는 멤버 초기자 리스트를 사용한다면, 그 항목들은 멤버 초기자 리스트에 나타나는 순서대로 초기화되지 않고, 그들이 선언된 순서대로 초기화된다.

##### 헬퍼 메서드

보조적인 역할로 사용되며, 있어도 그만 없어도 그만이라고 한다.

---

## private 상속

has-a 관계를 구현하는 제2의 수단

1. private 상속에서는, 기초 클래스의 public 멤버와 protected 멤버가 파생 클래스의 private 멤버가 된다.

> public 상속에서는 기초 클래스의 public 메서드가 파생 클래스의 public 메서드가 된다. 다시말해 파생 클래스는 기초 클래스의 인터페이스를 상속한다.

> 그러나 private 상속에서는 파생 클래스가 기초 클래스의 인터페이스를 상속하지 않는다.

2. 클래스가 구현을 상속한다.
3. 컨테인먼트는 객체를 이름이 있는 멤버 객체로 클래스에 추가한다. 반면 private 상속은, 객체를 이름이 없는 상속된 객체로 클래스에 추가한다.
4. private 상속은 컨테인먼트와 동일한 기능을 제공한다. 즉 구현은 획득하지만 인터페이스는 획득하지 않는다.

##### 다중 상속(MI): 기초 클래스가 하나 이상일 경우에 다중 상속이라고 부름, 그러나 문제가 많아 (특히 publuc MI) 업계에서는 사용하지 않고 인터페이스 포함 + 팩토리 패턴을 사용한다고 한다

예제 코드는 생략한다. 예시를 보면 알겠지만 기존에 작성 했던 코드에서 일부분만 수정했다.

``` cpp
1. 상속을 할때 디폴트 키워드는 private다. 하여 키워드를 생략하면 자동으로 private 상속이 되는데, 식별자를 써주는게 좋다.

2. 이 예제의 경우 private 다중 상속을 해야한다.

class Student : private std::string, private std::valarray<double>
{ ... }

3. private 상속은 기초 클래스 메서드를 파생 클래스 메서드의 안에서만 사용할 수 있도록 제한한다. 그러나 기초 클래스 기능을 public으로 사용하고 싶을때는 범위 결정 연산자로 호출할 수 있다.

double Student::Average() const
{ if(ArrayDb::size() > 0) ... }
```

##### 컨테인먼트와 private 상속

컨테인먼트와 private 상속 둘 중 어느 하나를 사용하여 has-a 관계를 모델링할 수 있다면, 어느 것을 사용해야 할까?

대부분의 개발자들은 컨테인먼트를 선호한다.

1. 사용하기 쉽다

> 클래스 선언을 들여다보고 내포된 클래스를 나타내는 객체가 명시적으로 이름이 지정되어 있고, 프로그램에서 이들 객체를 이름을 사용하여 참조할 수 있다.

2. 하나 이상의 기초 클래스로부터 클래스를 상속할 때, 상속이 문제를 일으킬 수 있기 때문이다.

그러나 private 상속은 컨티엔먼트가 제공하는 것 이상의 기능을 제공한다.

private 상속을 사용해야 하는 다른 상황은, 가상 함수를 다시 정의할 필요가 있을 때이다.

##### protected 상속

protected 상속은 private 상속의 변종이다. protected 상속은 기초 클래스를 나열할 때 키워드 protected를 사용한다.

protected 상속에서는 기초 클래스의 public 멤버와 protected 멤버가 파생 클래스의 protected 멤버가 된다.

private 상속과 마찬가지로 기초 클래스의 인터페이스를 파생 클래스에서 사용할 수 있지만, 바깥 세계에서는 사용할 수 없다.

``` c++
class Student : protected std::string, protected std::valarray<double>
{
    ...
};
```

protected 상속과 private 상속의 차이점은 파생 클래스로부터 또 다른 클래스를 파생시킬때 들어난다.

##### using을 사용하여 접근 다시 정의하기

protected 파생이나 private 파생을 사용할 때, 기초 클래스의 public 멤버들은 protected 멤버 또는 private 멤버가 된다.

어떤 특정 기초 클래스 메서드를 파생 클래스에서 public으로 사용할 수 있게 하고 싶다고 가정하자.

1. 기초 클래스 메서드를 사용하는 파생 클래스 메서드를 정의하는 방법

``` cpp
double Student::sum() const
{
    return std::valarray<double>::sum();
    // private로 상속된 메서드
}
```

2. 하나의 함수 호출을 다른 함수 안에 넣을 수 있는 방법. using 선언을 사용하여, 파생 클래스에서 사용할 특정 기초 클래스 멤버를 지정하는 것이다. 선언에서 작성할 수 있다.

``` cpp
class Student : private std::string, private std::valarray<double>
{
    ...
public:
    using std::valarray<double>::min;
    using std::valarray<double>::max;
};
```

3. private으로 파생된 클래스에 기초 클래스 메서드들을 다시 선언하는 방법 (사용하지 말것 -> using을 사용하는 이유를 퇴색시킨다.)

---

## 다중상속 (MI)

문제가 많아서 업계에서는 사용하지 않는다. 인터페이스 포함 + 팩토리 패턴을 주로 사용한다고 함

#### 예제 코드는 작성하지 않고 책으로만 보겠다

##### 가상 기초 클래스

하나의 공통 조상을 공유하는 여려 개의 기초 클래스부로부터 공통 조상의 유일 객체를 상속하는 방식으로 객체를 파생시키는 것을 허용한다.

아래의 코드는 클래스 선언에 키워드 virtual을 사용하여 Worker를 Singer와 Waiter의 가상 기초 클래스로 만든다. (virtual과 public이 나타내는 순서는 아무래도 좋다.)

``` cpp
class Singer : virtual public Worker {...};
class Waiter : public virtual Worker {...};
```

이렇게 하면 SingingWaiter를 전처럼 정의할 수 있다.

``` cpp
class SingingWaiter : public Singer, public Waiter
```

1032 페이지 내용 필독 !

1. 클래스가 간접적인 가상 기초 클래스를 가진다면, 가상 기초 클래스의 디폴트 생성자가 필요한 겨우를 제외하고, 그 클래스의 생성자는 가상 기초 클래스의 생성자를 명시적으로 호출해야 한다.

2. 다중 상속은 모호한 함수 호출을 일으킬 수 있다.

### ```다중 상속에 관한 문제```

1047p 확인

1. 가상 기초 클래스와 가상이 아닌 기초 클래스의 혼합

2. 가상 기초 클래스와 비교 우위

### 다중 상속 요약

어지간해서는 절대 사용하지 말자.

---

## 클래스 템플릿

상속과 컨테인먼트가 코드를 재활용하고 싶을 때 항상 해결책이 되는 것은 아니다.

10장 stack 클래스의 저장되는 객체만 다르고 코드는 동일한 부분은 typedef를 사용한다.

이 접근 방식에는 두가지 단점이 있다.

1. 데이터형을 변경할 때마다 헤더 파일을 수정해야 한다.
2. 프로그램당 한종류의 스택만 생성할 때 이 테크닉을 사용할 수 있다. 즉 typedef로는 동시에 두가지 데이터형을 나타낼 수 없다.

템플릿은 매개변수화 되는 데이터형을 제공한다.

즉 템플릿은 클래스나 함수 설계도에 데이터형 이름을 매개변수로 넘겨줄 수 있다.

```cpp
template <class Type>
/*
class는 데이터형을 값으로 받ㅇ아들이는 어떤 변수의 데이터형 이름의 역할을 하고, type은 그 변수의 이름을 나타낸다고 생각할 수 있다.
여기서 class를 사용하는 것은, Type이  반드시 클래스여야 한다는 것을 의미하지 않는다.
단지 Type이 사용될 때 실제 데이터형으로 대체되는 포괄 데이터형의 지정자 역할을 한다는 뜻이다.
*/

// 최신 컴파일러에서는 혼동을 막기 위해 class 대신에 typename을 사용할 수 있다.
template <typename Type>


// typedef 식별자인 Item을 Type으로 대체해야 한다.
Item items[MAX];
Type items[MAX];

// 오리지널 클래스의 클래스 메서드들을 템플릿 멤버 함수로 대체할 수 있다.
// 각각의 함수 머리에 동일한 템플릿 표시를 앞세운다. template <class Type>

// 마찬가지로 typedef 식별자인 Item을 포괄적인 데이터형 이름 Type을 대체해야 한다.
// 주의할점은 클래스 제한자를 Stack:: 에서 Stack<Type>:: 으로 변경해야 한다는 것이다.
bool Stack::push(const Item & item)
{ ... }
//를 아래와 같이 변경한다.
template <class Type> // or template <typename Type>
bool Stack<Type>::push (const Type & item)
{ ... }

// 클래스 선언 안에서 메서드를 정의한다면(인라인 정의), 템플릿 제한자와 클래스 제한자를 생략할 수 있다.
```

##### stacktp.hpp

클래스 템플릿과 멤버 함수 템플릿들이 결합된 것이다.

중요한점은 이 템플릿들이 클래스와 멤버 함수 정의가 아니라는 사실을 깨닫는 것이다.

이 템플릿들은 클래스와 멤버 함수 정의를 생성하는 방법을 컴파일러에게 알려주는 지시문이다.

#### ``` 포인터들의 스택을 잘못 사용하는 경우 [1059p ~ 1060p] ```

예제 코드를 포인터들의 스택을 사용할 수 있도록 개조하되, 간단한 결함이 있는 3가지 시도를 공부한다.

이 잘못된 시도들은, 템플릿을 무턱대고 사용할 것이 아니라 템플릿의 설계를 항상 마음속에 두어야 한다는 교훈을 알려준다.

잘못된 예제 3가지 모두 완벽하게 유효한 Stack\<Type> 템플릿의 발효로 시작된다.

> Stack\<char *> st;

```cpp
// 버전1
string po;
// 위 코드를 아래 구문으로 대체한다.
char * po;

// 이는 string 객체 대신에 char형을 지시하는 포인터를 사용하여 키보드 입력을 받아들이겠다는 생각이다.
// 포인터의 단순한 생성은 입력 문자열들의 저장 공간을 생성하지 않기 때문에, 이와 같은 접근은 즉시 실패한다.
```

``` cpp
// 버전 2
string po;
// 위 코드를 아래 구문으로 대체한다.
char po[40];

// 이것은 입력 문자열을 저장하기 위한 공간을 대입한다. 게다가 po는 char * 형이므로 스택에 넣을 수 있다.
// 그러나 배열은 pop() 메서드에서 약속한 가정과 기본적으로 불화를 일으킨다.
// 첫째. 참조 변수 item은 배열 이름이 아니라 어떤 종류의 Lvalue를 참조해야 한다.
// 둘째. 이 코드는 item에 대입할 수 있다고 가정한다. item이 어떤 배열을 참조할 수 있을지라도, 배열 이름에는 대입할 수 없다.
```

``` cpp
// 버전3
string po;
// 위 코드를 아래 구문으로 대체한다.
char* po = new char[40];

// 이것은 입력 문자열을 저장하기 위한 공간을 대입한다. 게다가 po가 변수이므로 pop()의 코드와 불화를 일으키지 않는다.
// 그러나 가장 근본적인 문제에 부닥친다. po 변수는 하나밖에 없고, 그것은 항상 같은 메모리 위치를 지시한다.
// 그 메모리 내용은 새로운 문자열을 읽을 때마다 바뀐다.
// 그러나 푸시 연산은 매번 정확히 동일한 주소를 스택에 넣는다. 그래서 스택을 팝하면 항상 동일한 주소를 얻는다.
// 그리고 그것은 메모리에 마지막으로 읽어들인 문자열을 항상 참조한다.
// 특히 그와 같은 스택은 새 문자열이 들어올 때마다 이들을 개별적으로 저장하지 않으므로, 유용한 용도로 사용할 수가 없다.
```

#### ``` 포인터들의 스택을 바르게 사용하는 경우 [1060p ~ 1066p] ```

포인터들의 스택을 사용하는 한 가지 방법은, 호출한 프로그램이 포인터들의 배열을 제공하는 것이다.

그 포인터들의 배열에서 각각의 포인터는 서로 다른 문자열을 지시한다.

이러한 포인터들을 스택에 넣는 것은, 각각의 포인터가 서로 다른 문자열을 참조하기 때문에 논리적으로 틀리지 않는다.

hpp 예제 코드에서 ```대입 연산자 함수의 리턴형``` Stack에 대한 참조로 선언하고, 실제 템플릿 함수 정의에서는 Stack\<Type>에 대한 참조로 선언한 것에 주목하라.

Stack은 Stack\<Type>의 약식 표기이고, 그 클래스 사용 범위 안에서만 사용할 수 있다.

그러나 리턴형을 인식할 때와 사용 범위 결정 연산자를 사용할 때와 같이, 그 클래스 바깥에서는 완전한 형식인 Stack\<Type>을 사용해야 한다.

##### ``` 코드 분석 ```

예제 코드의 문자열들은 결코 이동하지 않는다.

하나의 문자열을 스택에 푸시하면, 실제로는 기존의 문자열을 지시하는 새로운 포인터가 생성된다.

즉, 그것은 기존 문자열의 주소를 값으로 가지는 포인터를 생성한다.

하나의 문자열을 스택에서 팝 하면, 그 주소 값이 out 배열에 복사된다.

이 코드는 포인터들의 배열이 하나의 문자열 상수 집합으로 초기화되기 때문에, const char *를 데이터형으로 사용한다.

스택 소멸자는 그 문자열들에 아무런 영향도 미치지 않는다.

클래스 생성자는 new를 사용하여 포인터들을 저장할 배열을 생성한다.

클래스 소멸자는 그 배열을 삭제한다. 그러나 그 배열의 원소들이 지시하는 문자열들은 삭제하지 않는다.

---

### 배열 템플릿 예제와 데이터형이 아닌 매개변수

템플릿은 컨테이너 클래스에 자주 사용된다. 데이터형 매개변수의 개념이 다양한 데이터형에 공통으로 적용할 수 있는 저장 계획과 잘 맞아 떨어지기 떄문이다.

컨테이너 클래스들을 위해 재황용할 수 있는 코드를 제공하자는 것이 템플릿을 도입한 가장 큰 동기였다.

##### 예제코드

Stack 클래스 템플릿의 마지막 버전이 사용한 테크닉은, 클래스 안에서 동적 배열을 사용하고, 배열의 원소 수를 제공하기 위해 생성자 매개변수를 사용하는 것이다.

또 하나의 접근 방법은 일반 배열의 크기를 제공하기 위해 템플릿 매개변수를 사용하는 것인데, 이것이 C++11의 배열 템플릿의 역할이다.

> ArrayTP <double, 12> eggweights;

이것은 컴파일러에게 ArrayTP\<double, 12>라는 클래스를 정의하고 그 클래스의 eggweights 객체를 생성하라고 지시한다.

그 클래스를 정의할 때, 컴파일러는 T를 double로 대체하고 n을 12로 대체한다.

``` 수식 매개변수 제약 ```

1. 정수형, 열거형, 참조, 포인터가 수식 매개변수가 될 수 있다.
2. double m은 허용되지 않지만, double & rm이나 double * pm은 수식 매개변수로 허용된다.
3. 또한 그 템플릿 코드는 수식 매개변수의 값을 변경하거나 그것의 주소를 얻을 수 없다.
4. ArrayTP 템플릿에서, n++ 또는 &n과 같은 표현은 허용되지 않는다.
5. 템플릿을 구체화할 때, 수식 매개변수에 사용되는 값은 상수 수식이어야 한다.

```
배열의 크기를 수식 매개변수로 결정하는 이와 같은 접근방식은, Stack에서 사용한 생성자 접근 방식보다 하나의 장점을 가지고 있다.
생성자 접근 방식은 new와 delete에 의해 관리되는 힙(heap) 메모리를 사용하는 반면에, 수식 매개변수 접근 방식은 자동 변수들을 관리하는 스택 메모리를 사용한다. 특별히 이것은 크기가 작은 배열들을 많이 사용하는 경우에, 더 빠른 실행 속도를 제공한다.
```

수식 매개변수 접근 방식의 ```가장 큰 단점은```, 각 배열 크기가 자신만의 템플릿을 각각 생성한다는 것이다.

1. ArrayTP<double, 12> eggweights;
2. ArrayTP<double, 11> donuts;

> 위와 같은 선언은 서로 다른 두 개의 클래스 선언을 생성한다.

1. Stack<int> egg(12);
2. Stack<int> dunkers(13);

> 위와 같은 선언은 클래스 선언을 하나만 생성한다. 그리고 크기 정보는 그 클래스를 위한 생성자에 전달된다.

또 한가지 차이는, 생성자 접근 방식은 배열 크기를 정의에 코드로 직접 적어 넣지 않고 클래스 멤버로 저장하기 때문에 좀 더 융통성이 있다는 것이다.

예를 들면, 이것을 사용하여 한 크기의 배열로부터 다른 크기의 배열에 대입하는 것을 정의하거나 크기를 조절할 수 있는 배열을 허용하는 클래스를 만들 수 있다.

### 템플릿의 융통성

1. 보통의 클래스에 적용하는 것과 동일한 테크닉들을 템플릿 클래스에 적용할 수 있다.
2. 템플릿 클래스는 기초 클래스의 역할을 할 수 있다.
3. 성분 클래스가 될 수도 있다.
4. 그들 자신이 다른 템플릿들에 데이터형 매개변수가 될 수도 있다.

### 템플릿의 재귀적 사용

템플릿을 재귀적으로 사용할 수 있다는 것이, 템플릿의 융통성을 보여 주는 또 하나의 예이다.

> ArrayTP\< ArrayTP<int, 5>, 10> twodee;

위 코드는 twodee를 10개의 원소를 가진 배열로 만든다. 그 배열의 각 원소는 5개의 int값으로 이루어진 배열이다.

보통의 배열을 사용하는, 이와 동등한 선언은 다음과 같다. int twodee[10][5];

템프릿을 사용하는 문법은 보통의 2차원 배열을 사용하는 문법과 차원을 나타내는 순서가 반대이다.

예제코드 twodee.cpp로 확인해본다.

### 하나 이상의 데이터형 매개변수 사용

예를 들어, 두 종류의 값을 저장하는 클래스를 원한다고 가정하자.

종류가 전혀 다른 두 값을 저장하기 위해 Pair 템플릿 클래스를 생성하여 사용할 수 있다.

``` cpp
template <typename T1, typename T2>
class Pair
{
private:
    T1 a;
    T2 b;
public:
    T1 & first();
    T2 & second();
    T1 first() const { return a; }
    T2 second() const { return b; }
    Pair(const T1 & aval, const T2 & bval) : a(aval), b(bval) {}
}

template <typename T1, typename T2>
T1 & Pair<T1, T2>::first()
{
    return a;
}

template <typename T1, typename T2>
T2 & Pair<T1, T2>::second()
{
    return b;
}

int main()
{
    Pair<std::string, int> ratings[4] = 
    {
        Pair<std::string, int>("전지현", 5),
        Pair<std::string, int>("전지현", 5),
        Pair<std::string, int>("전지현", 5),
        Pair<std::string, int>("전지현", 5)
    };

    int joints = sizeof(ratings) / sizeof(Pair<string, int>);
    ...
}
```

위 코드에서 주목할점은 main에서 Pair\<std::string, int>를 생성자를 호출하는 데 사용해야 하고 sizeof의 매개변수로 사용해야 한다는 것이다.

그 이유는 클래스 이름이 Pair가 아니라 Pair\<std::string, int>이기 때문이다.

또한 Pair\<char *>, double>은 완전히 다른 클래스 이름이 될 것이다.

### 클래스 템플릿 디폴트 데이터형 매개변수

데이터형 매개변수들에 디폴트 값을 제공할 수 있다.

> template \<typename T1, typename T2 = int> class Topo { ... }

이것은 컴파일러에게 T2를 위한 값이 생략되었을 때 T2에 해당하는 데이터형으로 int를 사용하라고 지시한다.

Topo\<double, double> m1; // T1은 double, T2도 double

Topo\<double> m2; // T1은 double, T2는 int

표준 템플릿 라이브러리는, 클래스를 디폴트 데이터형으로 하여 이 기능을 자주 사용한다.

클래스 템플릿 데이터형 매개변수에는 디폴트 값을 제공할 수 있지만, 함수 템플릿 매개변수에는 디폴트 값을 제공할 수 없다.

그러나 클래스 템플릿과 함수 템플릿 두경우 모두, 데이터형이 아닌 매개변수에 대해서는 디폴트 값을 제공할 수 있다.

---

## 템플릿 특수화

클래스 템플릿은 암시적 구체화, 명시적 구체화, 명시적 특수화를 사용할 수 있다는 점에서 함수 템플릿과 비슷하다.

즉, 템플릿은 클래스를 포괄형으로 서술하는 반면에, 특수화는 구체적인 하나의 데이터형을 사용하여 생성한 클래스 선언이다.

특수화: 템플릿에서 특정 타입에 대해서 다른 실행 처리를 하고 싶을 때 그 타입에 대해서만 특수화. (암시적 구체화, 명시적 구체화, 명시적 특수화)

#### ``` 암시적 구체화 ```

챕터13의 템플릿 예제들은 암시적 구체화를 사용한다.

즉, 사용하기를 원하는 데이터형을 나타내는 하나 또는 그 이상의 객체를 선언한다. 그러면 컴파일러는 포괄적인 템플릿이 제공하는 설계도를 사용하여 하나의 특수화된 클래스 정의를 생성한다.

``` cpp
ArrayTP<int, 100> stuff; //암시적 구체화
// 컴파일러는 객체가 요구될 때까지 그 클래스의 암시적 구체화를 생성하지 않는다.

ArrayTP<double, 30> * pt; // 포인터, 아직 객체가 필요 없다.
pt = new ArrayTP<double, 30>; // 이제 객체가 요구된다.
// 두 번째 구문은 컴파일러에게 하나의 클래스 정의와, 그 정의에 따라 생성되는 하나의 객체를 생성하라고 지시한다.
```

#### ``` 명시적 구체화 ```

키워드 template을 사용하여 클래스를 선언하고, 사용하려는 데이터형을 나타냈을 때, 컴파일러는 명시적 구체화를 생성한다.

그 선언은 템플릿 정의와 동일한 이름 공간 안에 있어야 한다.

> template class ArrayTP\<string, 100>; // ArrayTP<string, 100> 클래스를 생성한다.

ArrayTP<string, 100>이 클래스라고 선언한다. 이 경우에 컴파일러는 그 클래스의 객체가 아직 생성되거나 언급되지 않았더라도, 메서드 정의들을 포함하여 그 클래스 정의를 생성한다.

암시적 구체화와 마찬가지로, 이 포괄적인 템플릿은 특수화를 생성하기 위한 설계도로 사용된다.

#### ``` 명시적 특수화 ```

명시적 특수화는 포괄적인 템플릿 대신에, 사용하려는 특정한 데이터형을 위한 정의이다.

때로는 템플릿이 특정형에 맞게 구체화될 때 조금 다르게 행동하도록 수정해야 하는 경우가 있다. 이러는 경우에 우리는 명시적 특수화를 생성할 수 있다.

T::operator> () 메서드가 정의되어 있을 때, T가 클래스형을 나타낸다면 잘 작동한다.

그러나 T가 char *형으로 나타내는 문자열이라면 이것은 동작하지 않는다.

실제로 템플릿은 동작하지만 문자열들이 알파벳순이 아니라 그들이 저장되어 있는 주소를 기준으로 정열된다.

그러므로 > 대신에 strcmp()를 사용하는 클래스 정의가 필요하다. 그러한 경우에 명시적 템플릿 특수화를 제공할 수 있다.

##### 특수화된 템플릿 정의

``` cpp
template <>
class Classname<specialized-type-name>
{
    ...
};
```

새로운 표기법을 사용하여 char * 형을 위한 특수화된 SortedArray 템플릿을 제공하려면 다음과 같은 코드를 사용할 수 있다.

``` cpp
template <>
class SortedArray<char *>
{
    ...
};
```

이 구현 코드는 배열의 값들을 비교하기 위해 > 대신 strcmp()를 사용할 것이다.

이제 char * 형을 위한 SortedArray 템플릿의 요청은, 포괄적인 템플릿 정의 대신에 특수화된 이 정의를 사용할 것이다.

``` cpp
SortedArray<int> scores; // 포괄적인 정의를 사용
SortedArray<char *> dates; // 특수화된 정의를 사용
```

#### ``` 부분적인 특수화 ```

C++는 부분적인 특수화도 허용한다. 부분적인 특수화는 템플릿의 포괄성을 일부 제한한다.

예를 들어, 부분적인 특수화는 데이터형 매개변수들중의 어느 하나에 구체적인 데이터형을 제공할 수 있다.

### 포괄적인 템플릿

``` cpp
template <class T1, class T2>
class Pair
{
    ...
};
```

### T2를 int로 설정한, 부분적인 특수화
``` cpp
template <class T1>
class Pair<T1, int>
{
    ...
};
```

키워드 template 뒤에 있는 <>는 특수화되지 않은 데이터형 매개변수들을 선언한다.

따라서 두 번째의 템플릿 선언은, T2를 int로 특수화하지만 T1은 그대로 남겨 둔다. 데이터형을 모두 지정하면, 괄호 쌍은 비게 되고 완전한 명시적 특수화가 이루어진다.

> template <> class Pair\<int, int> { ... };

여러 가지 중에서 하나를 선택해야 한다면, 컴파일러는 가장 특수화된 템플릿을 사용한다. (완전한 명시적 특수화 > 부분적인 특수화 > 포괄적)

또는 포인터들을 위한 특별한 버전을 제공함으로써, 기존의 템플릿을 부분적으로 특수화시킬 수 있다.

```cpp
template <typename type> // 포괄적인 버전
class Feeb
{
    ...
}

template <typename type*> // 포인터를 위한 부분적인 특수화
class Feeb
{
    ...
};
```

포인터가 아닌 데이터형을 제공하면, 컴파일러는 포괄적인 버전을 사용한다.

포인터를 제공하면 포인터를 위한 부분적인 특수화 버전을 사용한다.

부분적인 특수화 기능은 다양한 제한을 만드는 것을 허용한다. 예를들면 아래와 같은 것들을 사용할 수 있다.

```cpp
// 포괄적인 템플릿
template<typename T1, typename T2, typename T3>
class Trio
{
    ...
};

// T3을 T2로 설정하는 특수화
template <typename T1, typename T2>
class Trio<T1, T2, T2>
{
    ...
};

// T3과 T2를 T1*로 설정하는 특수화
template<typename T1>
class Trio<T1, T1*, T1*>
{
    ...
};

// 이와 같은 선언들이 주어지면, 컴파일러는 다음과 같이 선택한다.
Trio<int, short, char *> t1; // 1번 템플릿 사용
Trio<int, short> t2; // 2번 템플릿 사용
Trio<char, char*, char*> t3 // 3번 템플릿 사용
```

---

``` 참고 ```

1. 특수화를 하면 선언도 따로 해줘야한다.

```cpp
template<typename T>
class A 
{
public:
    A(const T& input)
    {}

    void doSomething()
    {
        cout << typeid(T).name() << endl;
    }
    
    void test()
    {}
};


template<>
class A<char>
{
public:
    A(const char& input)
    {}

    void doSomething()
    {
        cout << "Char type specialization" << endl;
    }
};

int main()
{
    A<int> a_int(1);
    A<double> a_double(3.14);
    A<char> a_char('a');
    
    a_int.doSomething();
    a_double.doSomething();
    a_char.doSomething();
    
    a_char.test(); // ❌에러❌

    return 0;
}
```

2. 특수화한 타입으로 구체화 될 땐 test() 멤버 함수가 없는 것이나 마찬가지다.

> 두번째 선언으로  구체화하기 때문

> 생성자도 따로 정의 해줘야 한다.

> > 그렇지 않으면 그냥 빈 내용의 디폴트 생성자를 컴파일러가 만들어 호출한다.

> > 원래 생성자 정의가 없었다면 상관없지만 원래 클래스 템플릿에 생성자가 있다면 정의해줘야 한다.

> C++17 부터는 생성자 매개변수로 들어가 인수로 T 타입을 알 수 있는 경우 <구체화타입>을 생력할 수 있다.

``` cpp
A a_int(1);   // 👉 int 로 구체화
A a_double(3.14);  // 👉 double 로 구체화
A a_char('a');   // 👉 char 로 구체화
```

### 멤버 템플릿

템플릿은 구조체, 클래스, 템플릿 클래스의 멤버가 될 수 있다.

``` tempmemb.cpp ``` 는 템플릿 클래스와 템플릿 함수를 멤버로 내포하고 있는, 템플릿 클래스의 짧은 예제이다.

hold 템플릿은 private 부분에 선언되어 있다. 그러므로 그것은 beta 클래스 사용 범위 내에서만 접근할 수 있다.

### 매개변수 템플릿

템플릿은 그 자체가 템플릿인 매개변수를 가질 수 있다. 템플릿 매개변수는, 표준 템플릿 라이브러리를 구현하기 위해 사용된, 최근에 추가된 템플릿 기능이다.

#### 예문

``` cpp
template <template<typename T> class Thing>
class Crab { };
```

템플릿 매개변수는 template \<typename T> class Thing이다.

여기서 template \<typename T> class가 데이터형이고, Thing이 매개변수이다.

> Crab\<King> legs;

선언은 이렇게 할 수 있다.

Crab 클래스를 정의할때는 아래와 같이 할 수  있다.

``` cpp
template <template <typename T> class Thing>
class Crab
{
private:
    Thing<int> s1;
    Thing<double> s2;
public:
    Crab() { };
    // Thing 클래스가 push(), pop() 멤버를 가지고 있다고 가정한다.
    bool push(int a, double x) { return s1.push(a) && s2.push(x); }
    bool pop(int & a, double & x) { return s1.pop(a) && s2.pop(x); }
};

```

또한 템플릿 매개변수를 일반 매개변수와 혼합하여 사용할 수 있다.

예를들면, Crab 클래스 선언은 다음과 같이 할 수 있다.

``` cpp
template <template <typename T> class Thing, typename U, typename V>
class Crab
{
private:
    Thing<U> s1;
    Thing<V> s2;
    ...
};
```

이제 멤버 s1, s2에 저장되는 데이터형은 내장 데이터형이 아니라 일반 데이터형이다.

이경우 선언을 다음과 같이 수정해야 한다.

> Crab\<Stack, int, double> nebula; // T=Stack, U=int, V=double

### 템플릿 클래스와 프렌드 함수

템플릿 클래스 선언도 프렌드를 가질 수 있다. 템플릿의 프렌드를 다음  3가지로 분류할 수 있다.

1. 템플릿이 아닌 프렌드.
2. 바운드 템플릿 프렌드, 클래스가 구체화될 때 클래스의 데이터형에 의해 프렌드의 데이터형이 결정된다.
3. 언바운드 템플릿 프렌드, 프렌드의 모든 특수화가 그 클래스의 각 특수화에 대해 프렌드들이다.

#### ``` 템플릿이 아닌 프렌드 예제코드 해석 ```

Hasfriend 템플릿은 ct라는 static 멤버를 하나 가진다. 이것은 그 클래스의 각 특별한 특수화가 그 자신만의 static 멤버를 가진다는 것을 의미한다.

Hasfriend의 모든 특수화에 대해 프렌드인 counts(), report() 메서드는, Hasfriend\<int> 와 Hasfriend\<double>이라는 두 특별한 특수화에 대해 각각 ct의 값을 보고한다.

#### ``` 템플릿 클래스에 대한 바운드 템플릿 프렌드 함수 ```

바운드 템플릿 프렌드: 클래스가 구체화될 때 클래스의 데이터형에 의해 프렌드의 데이터형이 결정되는 형태

※ 명시적 특수화가 정의된 외부 프렌드 함수에는 template 제한자가 붙지 않음에 유의하자. (왜냐하면, 그 함수들은 본질적으로 템플릿이 아니기 때문이다.)

예제 코드를 수정하여, 프렌드 함수들을 템플릿 자체로 만들 수 있다. 특별히 우리는 그것들을 바운드 템플릿 프렌드로 설정할 수 있다.

그래서 클래스의 각 특수화는 하나의 프렌드에 일치하는 특수화를 얻는다. 이것은 템플릿이 아닌 프렌드보다 다소 복잡하며 세 단계를 거친다.

1. 클래스 정의 앞에 템플릿 함수를 각각 선언

```cpp
template <typename T> void counts();
template <typename T> void report(T &);
```

2. 그 함수 안에서 다시 템플릿들을 프렌드로 선언한다. 이 구문들은 클래스 템플릿 매개변수의 데이터형에 기초하는 특수화들을 선언한다.

```cpp
template <typename TT>
class HasFriendT
{
    ...
    friend void counts<TT>();
    friend void report<>(HasFriendT<TT> &);
};
``` 

선언에 있는 \<>에 의해 이들은 템플릿 특수화로 인식된다. report()의 경우에, 함수 매개변수로부터 템플릿 데이터형 매개변수 HasFriend\<TT>를 유추할 수 있기 때문에, \<>를 빈 채로 둘 수 있다.

원한다면 report\<HasFriend\<TT>> (HasFriendT\<TT> &) 를 사용할 수 있다.

3. 프로그램은 그 프렌드들을 위한 정의를 제공해야 한다.

### 템플릿 클래스에 대한 언바운드 템플릿 프렌드 함수

언바운드 템플릿 프렌드: 프렌드의 모든 특수화가 그 클래스의 각 특수화에 대해 프렌드들인 형태

템플릿을 클래스 안에 선언함으로써, 언바운드 프렌드 함수를 생성할 수 있다. (바운드 프렌드 함수는 엄연히, 클래스 밖에 선언된다.)

모든 함수 특수화는 모든 클래스 특수화에 대해 프렌드이다.

언바운드 프렌드들의 경우에, 프렌드 템플릿 데이터형 매개변수들은 템플릿 클래스 데이터형 매개변수들과 다르다.

---

### 템플릿 별칭

데이터형을 위한 별칭을 정의하는 것은 템플릿 디자인에 편리성을 제공한다. 템플릿 특수화를 위한 별칭을 만들기 위해 typedef를 사용할 수 있다.

```cpp
typedef std::array<double, 12> arrd;
typedef std::array<int, 12> arri;
typedef std::array<std::string, 12> arrst;
arrd gallons;
arri days;
arrsy months;
```

아래의 코드는 arrtype을 데이터형으로 사용될 수 있는 템플릿 별칭으로 만든다.

```cpp
template<typename T>
using arrtype = std::array<T, 12>; // 다수의 별칭을 생성하기 위한 템플릿

arrtype<double> gallons;
arrtype<int> days;
arrtype<std::string> months;
```

즉 arrtype\<T>는 std::array\<T, 12> 자료형을 의미한다.
C++11은 또한 using = 구문을 비템플릿으로도 확장한다. 이 경우 typedef와 동일한 기능을 한다.

```cpp
typedef const char* pc1; // typedef 구문
using pc2 = const char*; // using = 구문
typedef const int * (*pa1)[10] // typedef 구문
using pa2 = const int *(*)[10] // using = 구문
```

---

## 챕터 13 마무리

단원 공부는 끝났지만 연습문제를 많이 풀고 복습이 필요할 것 같다.