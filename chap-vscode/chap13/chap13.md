# C++ 코드의 재활용

C++가 추구하는 중요한 목표 중의 하나가 코드의 재활용성을 높이는것

public 상속은 한 가지 방법일뿐 이번 장에서는 다른 방법들을 공부한다.

1. 컨테인먼트, 컴포지션, 레이어링: 다른 클래스에 속하는 객체를 클래스 멤버로 사용하는 것 (has-a 관계)
2. private 상속 or protected 상속 (has-a 관계)
3. 클래스 템플릿을 사용: 클래스를 포괄적으로 정의 가능, 그 템플릿을 사용하여 특정한 데이터형에 맞게 정의된 특정한 클래스를 생성할 수 있다.

> has-a 관계: 새로운 클래스가 다른 클래스의 객체를 포함하는 관계

---
## 객체 멤버를 가지는 클래스

템플릿 측면에서 보면, 객체를 선언할 때 구체적인 데이터형을 지정해야 한다.

그렇게 하려면 객체를 선언할 때 원하는 데이터형이 들어 있는 각괄호 앞에 식별자를 붙여야한다.

1. valarray &lt;int> q_values; -> int형의 배열
2. valarray &lt;double> weights; -> double형의 배열

클래스 측면에서 보면 valarray 객체를 사용하기 위해서는 클래스 생성자와 그외 클래스 메서드들에 관해 어떤 것을 알 필요가 있다.

1. valarray &lt;double> v1; -> double형의 배열, 크기 0
2. valarray &lt;int> v2(8); -> int형의 배열, 8개짜리 배열
3. valarray &lt;int> v3(10, 8); -> int형의 배열, 8개짜리 배열, 각각 10으로 설정
4. valarray &lt;double> v4(gpa, 4); -> double형 원소 4개짜리 배열, gpa의 첫 4개의 원소로 초기화

### Student 클래스 설계
학생은 이름이 아니고 성적표도 아니기 때문에 is-a 관계인 public 상속은 적합하지 않다.

학생은 이름과 성적표를 가지기 때문에 has-a 관계로 설계하는게 적합하다.

C++에서 has-a 관계를 모델링하는 일반적인 테크닉은, ```컴포지션(컨테인먼트)```을 사용하는 것이다.

즉, 다른 클래스의 객체들을 멤버로 가지는 클래스를 만드는 것이다.

예를 들면, 아래와 같이 클래스를 시작할 수 있다.

``` cpp
class Student
{
    private:
        string name;
        valarray<double> score;
}
```

보통 그 클래스는 데이터 멤버들을 private으로 선언한다.

##### 인터페이스의 구현
public 상속에서, 클래스는 인터페이스와 구현을 상속한다. 반면 컨테인먼트에서는 어떤 클래스가 인터페이스 없이 구현을 획득한다.

##### 멤버 초기자 리스트의 초기화 순서
하나 이상의 항목들을 초기화하는 멤버 초기자 리스트를 사용한다면, 그 항목들은 멤버 초기자 리스트에 나타나는 순서대로 초기화되지 않고, 그들이 선언된 순서대로 초기화된다.

##### 헬퍼 메서드
보조적인 역할로 사용되며, 있어도 그만 없어도 그만이라고 한다.

---
## private 상속
has-a 관계를 구현하는 제2의 수단

1. private 상속에서는, 기초 클래스의 public 멤버와 protected 멤버가 파생 클래스의 private 멤버가 된다.

> public 상속에서는 기초 클래스의 public 메서드가 파생 클래스의 public 메서드가 된다. 다시말해 파생 클래스는 기초 클래스의 인터페이스를 상속한다.

> 그러나 private 상속에서는 파생 클래스가 기초 클래스의 인터페이스를 상속하지 않는다.

2. 클래스가 구현을 상속한다.
3. 컨테인먼트는 객체를 이름이 있는 멤버 객체로 클래스에 추가한다. 반면 private 상속은, 객체를 이름이 없는 상속된 객체로 클래스에 추가한다.
4. private 상속은 컨테인먼트와 동일한 기능을 제공한다. 즉 구현은 획득하지만 인터페이스는 획득하지 않는다.

##### 다중 상속(MI): 기초 클래스가 하나 이상일 경우에 다중 상속이라고 부름, 그러나 문제가 많아 (특히 publuc MI) 업계에서는 사용하지 않고 인터페이스 포함 + 팩토리 패턴을 사용한다고 한다.

예제 코드는 생략한다. 예시를 보면 알겠지만 기존에 작성 했던 코드에서 일부분만 수정했다.

``` cpp
1. 상속을 할때 디폴트 키워드는 private다. 하여 키워드를 생략하면 자동으로 private 상속이 되는데, 식별자를 써주는게 좋다.

2. 이 예제의 경우 private 다중 상속을 해야한다.

class Student : private std::string, private std::valarray<double>
{ ... }

3. private 상속은 기초 클래스 메서드를 파생 클래스 메서드의 안에서만 사용할 수 있도록 제한한다. 그러나 기초 클래스 기능을 public으로 사용하고 싶을때는 범위 결정 연산자로 호출할 수 있다.

double Student::Average() const
{ if(ArrayDb::size() > 0) ... }
``` 

##### 컨테인먼트와 private 상속
컨테인먼트와 private 상속 둘 중 어느 하나를 사용하여 has-a 관계를 모델링할 수 있다면, 어느 것을 사용해야 할까?

대부분의 개발자들은 컨테인먼트를 선호한다.

1. 사용하기 쉽다
> 클래스 선언을 들여다보고 내포된 클래스를 나타내는 객체가 명시적으로 이름이 지정되어 있고, 프로그램에서 이들 객체를 이름을 사용하여 참조할 수 있다.

2. 하나 이상의 기초 클래스로부터 클래스를 상속할 때, 상속이 문제를 일으킬 수 있기 때문이다.

그러나 private 상속은 컨티엔먼트가 제공하는 것 이상의 기능을 제공한다.

private 상속을 사용해야 하는 다른 상황은, 가상 함수를 다시 정의할 필요가 있을 때이다.

##### protected 상속

protected 상속은 private 상속의 변종이다. protected 상속은 기초 클래스를 나열할 때 키워드 protected를 사용한다.

protected 상속에서는 기초 클래스의 public 멤버와 protected 멤버가 파생 클래스의 protected 멤버가 된다.

private 상속과 마찬가지로 기초 클래스의 인터페이스를 파생 클래스에서 사용할 수 있지만, 바깥 세계에서는 사용할 수 없다.

``` c++
class Student : protected std::string, protected std::valarray<double>
{
    ...
};
```

protected 상속과 private 상속의 차이점은 파생 클래스로부터 또 다른 클래스를 파생시킬때 들어난다.

##### using을 사용하여 접근 다시 정의하기

protected 파생이나 private 파생을 사용할 때, 기초 클래스의 public 멤버들은 protected 멤버 또는 private 멤버가 된다.

어떤 특정 기초 클래스 메서드를 파생 클래스에서 public으로 사용할 수 있게 하고 싶다고 가정하자.

1. 기초 클래스 메서드를 사용하는 파생 클래스 메서드를 정의하는 방법
``` cpp
double Student::sum() const
{
    return std::valarray<double>::sum();
    // private로 상속된 메서드
}
```
2. 하나의 함수 호출을 다른 함수 안에 넣을 수 있는 방법. using 선언을 사용하여, 파생 클래스에서 사용할 특정 기초 클래스 멤버를 지정하는 것이다. 선언에서 작성할 수 있다. 
``` cpp
class Student : private std::string, private std::valarray<double>
{
    ...
public:
    using std::valarray<double>::min;
    using std::valarray<double>::max;
};
```
3. private으로 파생된 클래스에 기초 클래스 메서드들을 다시 선언하는 방법 (사용하지 말것 -> using을 사용하는 이유를 퇴색시킨다.)

---

## 다중상속 (MI)

문제가 많아서 업계에서는 사용하지 않는다. 인터페이스 포함 + 팩토리 패턴을 주로 사용한다고 함

예제 코드와 발생할 수 있는 문제는 타이핑 하지 않고 책으로만 보겠다.