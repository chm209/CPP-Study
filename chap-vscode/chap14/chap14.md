# 프렌드, 예외, 기타사항

14장에서는 앞에서 맛보기로 배웠던 것들을 확실하게 배우고 예외, 실행 시간 데이터형 정보, 개선된 데이터형 변환 제어를 배워본다.s

## 프렌드

---

이 책에 지금까지 나온 예제들은, 프렌드 함수들을 클래스를 위한 확장 인터페이스의 일부로 사용한다.

그러한 함수들이 클래스가 가질 수 있는 프렌드의 유일한 종류는 아니다. ``` 클래스도 프렌드가 될 수 있다. ```

1. 프렌드 클래스의 모든 메서드는 오리지널 클래스의 private 멤버와 protected 멤버에 접근할 수 있다.
2. 또한 더욱 제한을 가하여 어떤 클래스의 특정 멤버 함수들만 다른 클래스의 프렌드가 되도록 지정할 수 있다.
3. 클래스는 함수, 멤버 함수, 클래스 중 어떤 것이 프렌드인지 정의한다.

### 프렌드 클래스

TV 클래스와 리모컨 클래스를 작성할때 TV는 리모컨이 아니고 리모컨도 TV가 아니기 때문에 is-a 관계가 아니다.

또한 리모컨은 TV의 성분이 아니고 TV도 리모컨의 성분이 아니기 때문에 has-a 관계가 아니다.

그런데 리모컨은 TV의 상태를 변경할 수 있다. 이것은 리모컨 클래스를 TV 클래스의 프렌드로 만들어야 하는것을 암시한다.

프렌드 선언은 public, private, protected 부분 어디에나 둘 수 있다. 위치에 따른 차이는 없다.

### 프렌드 멤버 함수

ex01 예제 코드를 살펴보면, 대부분의 Remote 메서드들은 Tv 클래스의 public 인터페이스를 사용하여 구현되었다는 것을 알 수 있다.

이것은 그 메서드들이 프렌드 자격을 필요로 하지 않는다는 뜻이다.

클래스 전체를 프렌드로 만드는 대신, 원하는 메서드들만 다른 클래스에 대해 프렌드로 만드는것이 가능하다. 그러나 그것은 조금 다루기 어렵다.

#### 사전 선언

Remote 정의가 Tv 정의 앞에 와야하는데 Remote 메서드들이 Tv 객체를 들먹인다는 사실은, Tv 정의가 Remote 정의 앞에 나타나야 한다는 것을 의미한다. 이것을 순환종속이라고 하고 이를 피하기 위해 사전 선언을 사용한다.

``` cpp
class Tv; // 사전선언
class Remote { ... };
class Tv { ... };
```

또 한가지의 문제가 있다. Remote 선언에는 아래와 같은 인라인 코드를 포함하고 있다.

```cpp
void onoff(Tv & t) { t.onoff(); }
```

이 코드는 Tv 메서드를 호출하기 때문에 컴팡이러는 Tv 클래스 선언을 이미 알고 있어야 하지만, Tv 선언은 Remote 뒤에 와야 한다

이 문제의 해결책은, Remote를 메서드 선언으로 제한하고 실제 정의들은 Tv 클래스 뒤에 두는 것이다.

```cpp
class Tv; // 사전선언
class Remote { ... }; // 리모트 메서드 원형
class Tv { ... }; // 여기에 리모드 메서드들의 실제 정의를 넣는다.
```

리모트 메서드의 원형을 조사할때 컴파일러는 사전 선언을 통해알 수 있다.

컴파일러는 티비 클래스 선언을 이미 알고 있고 리모트 메서드들을 컴파일하는 데 필요한 추가 정보를 알고 있다.

메서드 정의에 inline 키워드를 사용함으로써 그 메서드들을 여전히 인라인 메서드로 만들 수 있다.

```cpp
class Tv;

class Remote
{
public:
    ...
private:
    bool volup(Tv & t); // 원형만 정의
    ...
};

class Tv
{
    ... 그대로
}

// 인라인 함수로 선언된 Remote 메서드들
inline bool Remote::volup(Tv & t) { return t.volup; }
...

```

위 코드를 예제 hpp 코드와 교체하면 결과는 동일하다.

차이가 있다면 Remote의 모든 메서드가 아니라, 하나의 메서드만이 Tv 클래스에 대해 프렌드라는 것이다.

#### 그 밖의 프렌드 관계

```상호 프렌드 관계 (mutual friend)```

리모트 클래스의 일부 메서드들이 티비 클래스의 일부 메서드들에게 영향을 주고, 티비 클래스의 일부 메서드들이 리모트 클래스의 일부 메서드들에게 영향을 준다면 상호 프렌드 관계를 이용한다.

상호 프렌드 관계를 이용할때는 티비를 먼저 정의할때는 inline 키워드를 사용해야 한다.

> 티비 (원형만) - 리모트 (그대로) - inline 티비 메서드

```공유 프렌드```

하나의 함수가 서로 다른 두 클래스에 있는 private 데이터에 접근해야 할 때 그 함수는 각 클래스의 멤버 함수여야 한다.

그러나 그것은 불가능하다. 그 함수가 한 클래스의 멤버라면 다른 클래스에 대해서는 프렌드일 수 있다. 때로는 두 클래스 모두에 대해 프렌드로 만드는것이 합리적인 경우가 있다.

```cpp
class Analyzer; // 사전 선언
class Probe
{
    friend void sync(Analyzer & a, const Probe & p);
    friend void sync(Probe & p, const Analyzer & a);
    ...
};

class Analyzer
{
    friend void sync(Analyzer & a, const Probe & p);
    friend void sync(Probe & p, const Analyzer & a);
    ...
};

inline void sync(Analyzer & a, const Probe & p)
{
    ...
}

inline void sync(Probe & p, const Analyzer & a);
{
    ...
}
```

## 내포 클래스

1. C++에서는 클래스 선언을 다른 클래스 안에 내포시킬 수 있다.
2. 이것은 새로운 데이터형에 클래스 사용 범위를 제공함으로써 이름이 난잡해지는 것을 막는다.
3. 클래스 선언을 내포하고 있는 클래스의 멤버 함수들은, 내포 클래스의 객체들을 생성하여 사용할 수 있다.
4. 클래스 외부에서 내포 클래스 선언이 public 부분에 들어 있고, 사용 범위 결정 연산자를 사용해야만 내포 클래스를 사용할 수 있다.
5. 내포 클래스는 컨테인먼트와 다르다.
6. 내포 클래스 선언을 내포하고 있는 클래스에만 지역적으로 알려지는 하나의 데이터형을 정의한다.
7. 클래스를 내포시키는 일반적인 이유는, 다른 클래스의 구현을 지원하고, 이름 충돌을 막는 것이다.

> 포인터를 0으로 설정하는 것은 C++에서 널 포인터를 사용하는 한 가지 방법이다.

> NULL을 사용하려면 NULL을 정의하고 있는 헤더 파일을 포함시켜야 한다.

### 내포 클래스와 접근

내포 클래스에는 두 종류의 접근 형태가 있다.

1. 내포 클래스가 선언된 장소가 내포 클래스의 사용 범위를 제한한다.
2. 모든 클래스가 다 그렇듯이, 내포 클래스의 public, protected, private 부분들도 그 클래스 멤버에 대한 접근을 제한한다.

내포 클래스가 제2 클래스의 private 부분에 선언 -> 내포 클래스만 사용가능, 외부 클래스 사용불가, 내포 클래스에서 파생 클래스를 만들어도 사용불가

내포 클래스가 제2 클래스의 protected 부분에 선언 -> 내포 클래스와, 내포 클래스에서 파생한 클래스만 사용가능, 외부 클래스 사용불가

내포 클래스가 제2 클래스의 public 부분에 선언 -> 내포 클래스, 파생 클래스, 외부 클래스 사용가능

---

## 예외 (exception)

어쩔 수 없이 예외를 사용해야 하는 상황이 아니라면 Exception safe 프로그래밍을 지향해야 한다.

### abort() 호출

abort 함수의 원형은 cstdlib(또는 stdlib.h) 헤더 파일에 들어 있다.

일반적으로 abort 함수는, 호출되었을 때 표즌 에러 스트림에 "비정상적인 프로그램 종료" 와 같은 메시지를 보내고 프로그램을 종료시킨다.

### 에러 코드 리턴

비정상 종료보다 더 융통성 있는 방법은, 함수의 리턴값을 사용하여 문제가 무엇인지를 알리는 것이다.

### 예외 메커니즘

예외 처리는 다음과 같은 세 단계로 이루어진다.

1. 예외를 발생시킨다.
2. 핸들러를 사용하여 예외를 포착한다.
3. try 블록을 사용한다.

#### what 함수

예외 종류에 맞는 에러 원인 메세자를 리턴하는 기능을 하는 함수

에러 메세자를 리턴하므로 리턴 타입은 const char * 이다.

std::exception 클래스의 모든 자식 클래스는 virtual 가상 함수인 what() 함수를 오버라이딩한다.