# 프렌드, 예외, 기타사항

14장에서는 앞에서 맛보기로 배웠던 것들을 확실하게 배우고 예외, 실행 시간 데이터형 정보, 개선된 데이터형 변환 제어를 배워본다.s

## 프렌드

---

이 책에 지금까지 나온 예제들은, 프렌드 함수들을 클래스를 위한 확장 인터페이스의 일부로 사용한다.

그러한 함수들이 클래스가 가질 수 있는 프렌드의 유일한 종류는 아니다. ``` 클래스도 프렌드가 될 수 있다. ```

1. 프렌드 클래스의 모든 메서드는 오리지널 클래스의 private 멤버와 protected 멤버에 접근할 수 있다.
2. 또한 더욱 제한을 가하여 어떤 클래스의 특정 멤버 함수들만 다른 클래스의 프렌드가 되도록 지정할 수 있다.
3. 클래스는 함수, 멤버 함수, 클래스 중 어떤 것이 프렌드인지 정의한다.

### 프렌드 클래스

TV 클래스와 리모컨 클래스를 작성할때 TV는 리모컨이 아니고 리모컨도 TV가 아니기 때문에 is-a 관계가 아니다.

또한 리모컨은 TV의 성분이 아니고 TV도 리모컨의 성분이 아니기 때문에 has-a 관계가 아니다.

그런데 리모컨은 TV의 상태를 변경할 수 있다. 이것은 리모컨 클래스를 TV 클래스의 프렌드로 만들어야 하는것을 암시한다.

프렌드 선언은 public, private, protected 부분 어디에나 둘 수 있다. 위치에 따른 차이는 없다.

### 프렌드 멤버 함수

ex01 예제 코드를 살펴보면, 대부분의 Remote 메서드들은 Tv 클래스의 public 인터페이스를 사용하여 구현되었다는 것을 알 수 있다.

이것은 그 메서드들이 프렌드 자격을 필요로 하지 않는다는 뜻이다.

클래스 전체를 프렌드로 만드는 대신, 원하는 메서드들만 다른 클래스에 대해 프렌드로 만드는것이 가능하다. 그러나 그것은 조금 다루기 어렵다.

#### 사전 선언

Remote 정의가 Tv 정의 앞에 와야하는데 Remote 메서드들이 Tv 객체를 들먹인다는 사실은, Tv 정의가 Remote 정의 앞에 나타나야 한다는 것을 의미한다. 이것을 순환종속이라고 하고 이를 피하기 위해 사전 선언을 사용한다.

``` cpp
class Tv; // 사전선언
class Remote { ... };
class Tv { ... };
```

또 한가지의 문제가 있다. Remote 선언에는 아래와 같은 인라인 코드를 포함하고 있다.

```cpp
void onoff(Tv & t) { t.onoff(); }
```

이 코드는 Tv 메서드를 호출하기 때문에 컴팡이러는 Tv 클래스 선언을 이미 알고 있어야 하지만, Tv 선언은 Remote 뒤에 와야 한다

이 문제의 해결책은, Remote를 메서드 선언으로 제한하고 실제 정의들은 Tv 클래스 뒤에 두는 것이다.

```cpp
class Tv; // 사전선언
class Remote { ... }; // 리모트 메서드 원형
class Tv { ... }; // 여기에 리모드 메서드들의 실제 정의를 넣는다.
```

리모트 메서드의 원형을 조사할때 컴파일러는 사전 선언을 통해알 수 있다.

컴파일러는 티비 클래스 선언을 이미 알고 있고 리모트 메서드들을 컴파일하는 데 필요한 추가 정보를 알고 있다.

메서드 정의에 inline 키워드를 사용함으로써 그 메서드들을 여전히 인라인 메서드로 만들 수 있다.

```cpp
class Tv;

class Remote
{
public:
    ...
private:
    bool volup(Tv & t); // 원형만 정의
    ...
};

class Tv
{
    ... 그대로
}

// 인라인 함수로 선언된 Remote 메서드들
inline bool Remote::volup(Tv & t) { return t.volup; }
...

```

위 코드를 예제 hpp 코드와 교체하면 결과는 동일하다.

차이가 있다면 Remote의 모든 메서드가 아니라, 하나의 메서드만이 Tv 클래스에 대해 프렌드라는 것이다.

#### 그 밖의 프렌드 관계

```상호 프렌드 관계 (mutual friend)```

리모트 클래스의 일부 메서드들이 티비 클래스의 일부 메서드들에게 영향을 주고, 티비 클래스의 일부 메서드들이 리모트 클래스의 일부 메서드들에게 영향을 준다면 상호 프렌드 관계를 이용한다.

상호 프렌드 관계를 이용할때는 티비를 먼저 정의할때는 inline 키워드를 사용해야 한다.

> 티비 (원형만) - 리모트 (그대로) - inline 티비 메서드

```공유 프렌드```

하나의 함수가 서로 다른 두 클래스에 있는 private 데이터에 접근해야 할 때 그 함수는 각 클래스의 멤버 함수여야 한다.

그러나 그것은 불가능하다. 그 함수가 한 클래스의 멤버라면 다른 클래스에 대해서는 프렌드일 수 있다. 때로는 두 클래스 모두에 대해 프렌드로 만드는것이 합리적인 경우가 있다.

```cpp
class Analyzer; // 사전 선언
class Probe
{
    friend void sync(Analyzer & a, const Probe & p);
    friend void sync(Probe & p, const Analyzer & a);
    ...
};

class Analyzer
{
    friend void sync(Analyzer & a, const Probe & p);
    friend void sync(Probe & p, const Analyzer & a);
    ...
};

inline void sync(Analyzer & a, const Probe & p)
{
    ...
}

inline void sync(Probe & p, const Analyzer & a);
{
    ...
}
```

### 내포 클래스

1. C++에서는 클래스 선언을 다른 클래스 안에 내포시킬 수 있다.
2. 이것은 새로운 데이터형에 클래스 사용 범위를 제공함으로써 이름이 난잡해지는 것을 막는다.