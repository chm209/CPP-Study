#include <iostream>
void ex01(void);
void ex02(void);
void ex03(void);
void ex04(void);

int main(void)
{
	// 함수의 활용
	// C에는 없고 C++에 추가된 기능들
	// ex01();
	// ex02();
	ex03();
	ex04();

	return 0;
}

void ex01(void)
{
	// C++ 인라인 (inline) 함수
	// 프로그램의 실행 속도를 높이기 위해 보강된 기능
	// 컴파일된 함수 코드가 프로그램의 다른 코드 안에 직접 삽입되어 있다.
	// 인라인 코드를 이용하면 함수를 그 자리에서 처리하므로 인라인 함수는 일반 함수보다 약간 빠르게 수행된다.
	// 메모리 사용 측면에서는 인라인 함수는 일반 함수보다 불리하다.
	// 인라인 함수 사용여부는 신중하게 결정해야 한다.
	// 함수 코드 자체를 수행하는 데 걸리는 시간이, 함수 호출의 과정을 처리하ㅡㄴ 데 걸리는 시간에 비해 매우 길다면 전체적으로 절약되는 시간은 거의 없다.
	// 함수 코드를 수행하는 데 걸리는 시간이 매우 짧을 경우에만 인라인 함수를 사용하는 것이 일반 함수를 사용하는 것보다 시간이 절약된다.
	// 
	// 사용방법
	// 1. 함수 선언 앞에 inline 이라는 키워드를 붙인다. 
	// 2. 함수 정의 앞에 inline 이라는 키워드를 붙인다.
	// 둘중에 하나는 해야함
	// 지금까지 C의 매크로를 사용해왔다면 inline 함수로 변환하는 것을 고려해야 한다.

	// 참조 변수
	// 주된 용도는 함수의 형식 매개변수에 사용하는 것이다.
	// 참조를 매개변수로 사용하면, 그 함수는 복사본 대신 원본 데이터를 가지고 작업한다.
	// 덩치 큰 구조체를 처리해야 하는 함수에서 포인터 대신에 참조를 사용할 수 있다.
	// 클래스를 설계할때 필수적으로 사용한다.
	// & 기호는 C,C++에서 주소를 나타내는 연산자의 기능이 있지만
	// 참조 변수를 생성하기 위해 사용하기도 한다.

	int rats;
	int& rodents = rats; // rodents를 rats의 대용 이름으로 만든다. (참조)
	int* prats = &rats; // prats는 포인터이다.
	// 여기에서 & 연산자는 주소 연산자가 아니라. 데이터형 식별자의 일부로 사용된 것이다.
	// char*가 문자를 지시하는 포인터를 의미하는 것처럼, int&는 int에 대한 참조를 의마한다.
	// 이 둘은 모두 같은 값과 같은 메모리 위치를 참조한다.
	// 포인터와 참조는 비슷하지만 차이점이 있다.
	int num;
	// int& cham; → 불가능
	// cham = num; → 불가능
	// 참조를 선언할 때 참조 변수를 함께 초기화 해야 한다.
	// 참조는 const 포인터와 상당히 비슷하다.
	int& cham = num; // → 본질적으로 같은 것임
	int* const chamcham = &num; // → 본질적으로 같은 것임
	rodents = num; //  → 참조는 도중에 변경할 수 없다.
	// 저렇게 하면 rats, rodents의 값이 num 값으로 바뀌지  rodents가 num 주소를 가리키지는 않는다.
	int ppt1 = 101;
	int* qwe1 = &ppt1;
	int& asd1 = *qwe1;
	int bbb1 = 50;
	qwe1 = &bbb1;
	// 이렇게 하면 qwe1 은 ppt1을 가리키고 asd1은 qwe1을 가리키니깐 결국 asd1도 ppt1을 가리킨다.
	// qwe1가 bbb1을 가리키도록 해도 asd1은 ppt1을 가리킨다.

	// 함수 매개변수로서의 참조
	// 기존처럼 호출할때 int t를 넘겨서 int q로 받으면 q에 t값을 복사한다는 의미인데
	// int t를 넘겨서 int& q로 받으면 q가 t를 참조해서 값과 주소 모두 t를 가리킨다.
	// 함수에 전달하는 정보를 그 함수가 변경하지 않고 사용만 하도록 하려면 상수 참조를 사용해야 한다.
	// 예를 들면 함수 원형과 함수 머리에 다음과 같이 const를 사용해야 한다.
	// ex01(const int &ra)
	// 이렇게 하면 ra를 변경하려고 시도하는 코드에서 에러가 난다.
	// 간단한 함수를 작성할 때에는, 쓸데없이 참조로 전달하지 말고 값으로 전달해야 한다.
	// 참조 매개변수는 구조체나 클래스와 같이 덩치 큰 데이터를 다룰 때에나 유익하다.

	// 임시 변수, 참조 매개변수, const
	// C++는 실제 매개변수와 참조 매개변수가 일치하지 않을 때 임시 변수를 생성할 수 있다. (매개변수가 const 참조일 경우에만 허용)
	// 임시변수가 생성되는 상황 (참조 매개변수가 const일 경우)
	// 1. 실제 매개변수가 올바른 데이터형이지만 lvaule가 아닐 때
	// 2. 실제 매개변수가 잘못된 데이터형이지만 올바른 데이터형으로 반환할 수 있을 때
	// ### lvalue란 
	// ▶ lvalue 매개변수는 참조가 가능한 데이터 객체이다.
	// ▶ 변수, 배열의 원소, 구조체의 멤버, 참조 또는 역참조 포인터는 lvalue이다.
	// ▶ 일반 상수(주소에 의해서 표시되는 인용 구문과는 별개)와 여러 개의 항으로 이루어진 표현식은 lavlue가 아니다.
	// ▶ C 에서는 대입문 왼편에 있는게 lvalue 였지만 const는 아님
	// ! 참조 형식 매개변수를 const로 선언하는 것이 좋다.
	
	// rvalue 참조
	double&& twotwo = 2.0 + 18.5;
	// double& twoone = 2.0 + 18.5; → 허용하지 않음
	// 라이브러리를 만들때 특정 기능을 더욱 효율적으로 구현할 수 있도록 돕는 가능

	// 구조체에 대한 참조
	// 구조체 매개변수를 선언할 때 참조 연산자를 앞에 붙이면 된다.
	// void test(this_is & ts)
	
	// 참조 리턴을 하는 이유
	// 일반적인 리턴을 하면 값을 임시 공간에 저장을 하고 대상에 복사를 하지만
	// 참조 리턴을 하면 직접적으로 복사를 하기 때문에 보다 효율적이다.
	// 참조 리턴을 할때는 함수가 종료될때 수명이 함께 끝나는 메모리 위치에 대한 참조를 리턴하지 않도록 조심해야 한다.
	
	// 참조를 리턴할때 const를 사용하는 이유
	//	모호한 코드는 에러를 일으킬 확률을 높이기 때문에 설계할 때 모호한 코드를 추가하지않도록 하는 것이 좋다.
	// 리턴형을 const 참조로 만드는 것은 프로그래머가 모호한 에러를 만들지 않는 좋은 방법이다.
	// 경우에 따라서는 const를 쓰지 않는 것이 옳을 때도 있다.

	// 클래스 객체와 참조
	// 일반적으로 C++는 클래스 객체를 함수에 전달할 때 참조를 사용한다.

	// 참조 매개변수는 언제 사용하는가?
	// 호출 함수에 있는 데이터 객체의 변경을 허용하기 위해서
	// 전체 데이터 객체 대신에 참조를 전달하여 프로그램의 속도를 높이기 위해서
}

void ex02(void)
{
	// 디폴드 매개변수
	// 함수 호출에서 실제 매개변수를 생략했을 경우에 실제 매개변수 대신 사용되는 값이다.
	// 디폴트 매개변수는 함수 사용에 매우 큰 융통성을 부여한다.
	// 매개변수 리스트를 사용할 때에는 디폴트 매개변수를 오른쪽에서 왼쪽의 순서로 첨가해야 한다,
	// 즉, 어떤 매개변수를 디폴트 매개변수로 만들려면, 그 매개변수 보다 오른쪽에 있는 모든 매개변수를 디폴트 매개변수로 만들어야 한다.
	/*
	EX)
	char* left(const char* str, int n = 1); // 함수 선언부 int n=1을 디폴트 매개변수로 설정
	void test(int i = 1, x = 2, y = 3);
	↓ 디폴트 매개변수를 사용안 하는 호출
	char* ps = left(sample, 4);
	test(4,5,6);
	↓ 디폴트 매개변수를 사용하는 호출
	char* ps = left(sample);
	test(4,5);
	test(4);
	↓ 잘못된 호출
	test(4, ,6); // 생략 불가
	*/
}

void ex03(void)
{
	// 함수 오버로딩
	// 서로 다른 여러 개의 함수가 하나의 이름을 공유하는 것이다.
	// 함수 시그내처 → 함수의 매개변수 리스트
	// 컴파일러가 매개변수의 개수, 데이터형을 파악한다.
	// (int t) 와 (int & t)는 구분 못함 시그내처가 같음
	// const와 const가 아닌것은 구분한다. 다만, 시그내처가 같은 경우 const가 아닌 매개변수를 사용하는 호출에만 반응한다.
	// 함수 오버로딩이 가능하게 하는 것은 함수의 데이터형이 아니라 시그내처다.
	// int test(int, double);
	// double test(int, double); → 리턴형이 달라도 둘의 시그내처는 동일하기 때문에 사용할 수 없다
	// int test(char, double); → 사용가능

	// 함수 오버로딩은 과용하면 안 된다.
	// 서로 다른 데이터형을 대상으로 하지만 기본적으로는 같은 작업을 수행하는 함수들에만 사용하는 것이 바람직하다.
	// 또한, 디폴트 매개변수를 사용하여 같은 목적을 수행할 수 있는지 확인하는 것이 좋다.
}

void ex04(void)
{

}