#include <iostream>
void ex01(void);
void ex02(void);
void ex03(void);
void ex04(void);

int main(void)
{
	// 함수의 활용
	// C에는 없고 C++에 추가된 기능들
	ex01();
	ex02();
	ex03();
	ex04();

	return 0;
}

void ex01(void)
{
	// C++ 인라인 (inline) 함수
	// 프로그램의 실행 속도를 높이기 위해 보강된 기능
	// 컴파일된 함수 코드가 프로그램의 다른 코드 안에 직접 삽입되어 있다.
	// 인라인 코드를 이용하면 함수를 그 자리에서 처리하므로 인라인 함수는 일반 함수보다 약간 빠르게 수행된다.
	// 메모리 사용 측면에서는 인라인 함수는 일반 함수보다 불리하다.
	// 인라인 함수 사용여부는 신중하게 결정해야 한다.
	// 함수 코드 자체를 수행하는 데 걸리는 시간이, 함수 호출의 과정을 처리하ㅡㄴ 데 걸리는 시간에 비해 매우 길다면 전체적으로 절약되는 시간은 거의 없다.
	// 함수 코드를 수행하는 데 걸리는 시간이 매우 짧을 경우에만 인라인 함수를 사용하는 것이 일반 함수를 사용하는 것보다 시간이 절약된다.
	// 
	// 사용방법
	// 1. 함수 선언 앞에 inline 이라는 키워드를 붙인다. 
	// 2. 함수 정의 앞에 inline 이라는 키워드를 붙인다.
	// 둘중에 하나는 해야함
	// 지금까지 C의 매크로를 사용해왔다면 inline 함수로 변환하는 것을 고려해야 한다.

	// 참조 변수
	// 주된 용도는 함수의 형식 매개변수에 사용하는 것이다.
	// 참조를 매개변수로 사용하면, 그 함수는 복사본 대신 원본 데이터를 가지고 작업한다.
	// 덩치 큰 구조체를 처리해야 하는 함수에서 포인터 대신에 참조를 사용할 수 있다.
	// 클래스를 설계할때 필수적으로 사용한다.
	// & 기호는 C,C++에서 주소를 나타내는 연산자의 기능이 있지만
	// 참조 변수를 생성하기 위해 사용하기도 한다.

	int rats;
	int& rodents = rats; // rodents를 rats의 대용 이름으로 만든다. (참조)
	int* prats = &rats; // prats는 포인터이다.
	// 여기에서 & 연산자는 주소 연산자가 아니라. 데이터형 식별자의 일부로 사용된 것이다.
	// char*가 문자를 지시하는 포인터를 의미하는 것처럼, int&는 int에 대한 참조를 의마한다.
	// 이 둘은 모두 같은 값과 같은 메모리 위치를 참조한다.
	// 포인터와 참조는 비슷하지만 차이점이 있다.
	int num;
	// int& cham; → 불가능
	// cham = num; → 불가능
	// 참조를 선언할 때 참조 변수를 함께 초기화 해야 한다.
	// 참조는 const 포인터와 상당히 비슷하다.
	int& cham = num; // → 본질적으로 같은 것임
	int* const chamcham = &num; // → 본질적으로 같은 것임
	rodents = num; //  → 참조는 도중에 변경할 수 없다.
	// 저렇게 하면 rats, rodents의 값이 num 값으로 바뀌지  rodents가 num 주소를 가리키지는 않는다.
	int ppt1 = 101;
	int* qwe1 = &ppt1;
	int& asd1 = *qwe1;
	int bbb1 = 50;
	qwe1 = &bbb1;
	// 이렇게 하면 qwe1 은 ppt1을 가리키고 asd1은 qwe1을 가리키니깐 결국 asd1도 ppt1을 가리킨다.
	// qwe1가 bbb1을 가리키도록 해도 asd1은 ppt1을 가리킨다.

	// 함수 매개변수로서의 참조
	// 기존처럼 호출할때 int t를 넘겨서 int q로 받으면 q에 t값을 복사한다는 의미인데
	// int t를 넘겨서 int& q로 받으면 q가 t를 참조해서 값과 주소 모두 t를 가리킨다.
	// 함수에 전달하는 정보를 그 함수가 변경하지 않고 사용만 하도록 하려면 상수 참조를 사용해야 한다.
	// 예를 들면 함수 원형과 함수 머리에 다음과 같이 const를 사용해야 한다.
	// ex01(const int &ra)
	// 이렇게 하면 ra를 변경하려고 시도하는 코드에서 에러가 난다.
	// 간단한 함수를 작성할 때에는, 쓸데없이 참조로 전달하지 말고 값으로 전달해야 한다.
	// 참조 매개변수는 구조체나 클래스와 같이 덩치 큰 데이터를 다룰 때에나 유익하다.




}

void ex02(void)
{

}

void ex03(void)
{

}

void ex04(void)
{

}