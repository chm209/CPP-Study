#include <iostream>
void ex01(void);
void ex02(void);
void ex03(void);
void ex04(void);

void main()
{
	ex01();
	ex02();
	ex03();
	ex04();
}

void ex01(void)
{
	// ◈ 메모리 모델과 이름 공간
	// ※ C++에서는 메모리에 데이터를 여러 가지 방법으로 저장할 수 있다.
	// ※ 데이터를 메모리에 얼마나 오래 존속시킬 것인지 (기억 존속 시간), 데이터에 대한 접근을 프로그램의 어느 부분에만 허용할 것인지 (사용 범위, 링크) 등을 사용자가 선택할 수 있다.
	// ※ new 키워드를 사용하여 메모리를 동적으로 대입할 수 있다. 그리고 위치 지정 new는 그 기술의 한 변형을 제공한다.
	// ※ C++의 이름 공간 기능은 데이터 접근을 사용자가 추가로 제어할 수 있도록 해 준다.
	// ※ 일반적으로 덩치 큰 프로그램들은 데이터를 공유하는 여러 개의 소스 코드 파일들로 구성되고, 파일을 분할해서 컴파일 할 수 있다.

	// ◈ 분할 컴파일
	// ※ C & C++은 프로그램을 구성하는 함수들을 별개의 파일에 넣는 것을 권장한다.
	// ※ 파일들을 개별적으로 분할하여 컴파일한 후에, 그것들을 하나의 최종 실행 프로그램으로 링크할 수 있다.
	// ↓ 원본 프로그램을 이와 같이 분할할 수 있다.
	// 1. 구조체 선언과, 그 구조체를 사용하는 함수들의 원형이 들어 있는 헤더파일
	// 2. 그 구조체에 관련된 함수들의 코드가 들어 있는 소스 코드 파일
	// 3. 그 구조체에 관련된 함수들을 호출하는 코드가 들어 있는 소스 코드 파일
	// ↓ 헤더 파일 규칙
	// 1. 함수 정의나 변수 선언은 절대 금물
	// 2. 함수 원형
	// 3. #define이나 const를 사용하여 정의하는 기호 상수
	// 4. 구조체 선언
	// 5. 클래스 선언
	// 6. 템플릿 선언
	// 7. 인라인 함수
	// ▶ 563페이지 헤더 파일 관리 팁 있음

	// ◈ 기억 존속 시간, 사용범위, 링크 
	// ↓ C++는 네 가지 유형으로 데이터를 저장한다. 이 네 가지 유형은 메모리에 데이터를 존속시키는 시간에서 차이가 난다.
	// 1. 자동 기억 존속 시간: 함수 매개변수를 포함하여, 함수 정의 안에 선언된 변수, 로컬 변수를 말하는듯
	// 2. 정적 기억 존속 시간: 전역 변수, static 키워드를 사용한 변수
	// 3. 쓰레드 존속 시간: 연산 작업을 thread 단위로 쪼개서 처리할 수  있다.
	// 4. 동적 기억 존속 시간: new 연산자를 사용하여 대입된 메모리, delete로 해제하거나 프로그램을 종료할때까지 존속한다.
	// ↓ 사용범위와 링크
	// ※ 사용범위는 어떤 이름이 하나의 파일 (번역 단위) 안에서 얼마나 널리 알려지는가를 나타낸다. (EX) 지역변수, 전역변수, 외부변수 )
	// ※ 링크는 서로 다른 번역 단위들이 이름을 공유하는 것을 말한다.
	// 1. 외부 링크를 가진 이름은 여러 파일들이 공유할 수 있다.
	// 2. 내부 링크를 가진 이름은 한 파일 안에 있는 함수들만 공유할 수 있다.
	// 3. 자동 변수는 공유되지 않기 때문에 자동 변수의 이름은 링크르 갖지 않는다.
	// ↓ 자동 변수
	// ※ 함수 매개변수와, 함수 안에서 선언된 변수는 기본적으로 자동 기억 존속 시간을 가진다.
	// ※ 이들은 또한 지역 사용 범위를 가지며, 링크는 없다.
	// ↓ 레지스터 변수
	// 1. 원래 C에서는 register 키워드를 제공해서 컴파일러가 CPU 레지스터를 사용해서 자동 변수를 저장할 것을 제안했다.
	// 2. 변수에 더욱 빨리 접근하는 것을 허용하기 위함이었다.
	// 3. C++11 이전에는 레지스터 키워드가 자주 사용되는 변수라는 의미, 컴파일러가 해당 변수에 특별한 조치를 취한다는 의미로 일반화하여 목적을 추구했다.
	// 4. C++11 에서는 이러한것들이 사라졌지만 레지스터 키워드를 어떤 한 변수가 자동적임을 명시하도록 남겨두었다.
	// 5. auto 키워드가 동일 기능을 지원하지만, 레지스터 키워드를 보존하는 이유는 기존의 코드가 인식이 불가능해지는 것을 방지하기 위함이다. (레거시 라고 생각하면 될듯)
	// ↓ 정적 변수
	// ※ C와 마찬가지로 C++는 세가지 유형의 링크(외부, 내부, 링크 없음)를 가지는 정적 변수를 제공한다.
	// ※ 세 가지 유형 모두 프로그램이 실행되는 전체 시간 동안 존속한다. 자동 변수보다 수명이 길다.
	// 기억 공간        | 기억 존속 시간 | 사용 범위 | 링크 | 선언 방법
	// 자동                | 자동                | 블록        | 없음 | 블록안에
	// 레지스터         | 자동                 | 블록        | 없음 | 블록안에 register 사용
	// 링크 없는 정적 | 정적                | 블록        | 없음 | 블록 안에 static 사용
	// 외부 링크 정적 | 정적                | 파일        | 외부 | 함수의 바깥에
	// 내부 링크 정적 | 정적                | 파일        | 내부 | 함수의 바깥에 static 사용
	// ↓ 정적 존속 시간, 외부 링크
	// ※ 외부 연계성을 지닌 변수는 종종 단순히 외부 변수로 부른다.
	// ※ 외부 변수는 정적 저장 기간과 파일 범위를 지닌다, 외부 변수는 외부에서 정의되기 때문에 다른 외부 함수와 연계된다.
	// ↓↓ 단일 정의 원칙
	// 1. 외부 변수가 그 변수를 사용하는 모든 각각의 파일에서 선언되어야 한다.
	// 2. C++에서는 하나의 변수에 대하여 오직 하나의 정의를 부여하는 "단일 정의 원칙"을 명시하고 있다.
	// ※ 이러한 요구 사항을 충족하기 위해 C++은 두종류의 변수 선언을 한다.
	// 1. 선언을 정의하는 것 또는 단순하게 정의로, 대입되는 변수에 대하여 저장소를 제공한다.
	// 2. 참조 선언 혹은 단순히 선언하는 것인데, 이 경우엔 기존의 변수를 의미하므로 저장소를 생성하지 않는다.
	// ※ 참조 선언은 extern이라는 키워드를 사용하고 초기화를 제공하지 않는다.
	// ※ 만약 여러 파일에서 외부 변수가 사용될 경우, 오직 한 개의 파일이 그 변수에 대한 정의를 지닐 수 있다. (유일 정의 원칙)
	// ※ 그 변수를 사용하는 다른 모든 파일들은 그 변수를 extern이라는 키워드를 사용해서 선언해 줄 필요가 있다.
	//
}

void ex02(void)
{

}

void ex03(void)
{

}

void ex04(void)
{

}