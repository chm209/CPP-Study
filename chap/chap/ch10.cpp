#include <iostream>
void ex01(void);

int main(void)
{
	using std::cout;
	using std::endl;
	ex01();

	return 0;
}

void ex01(void)
{
	/*
	* ♠ 클래스의 활용
	
	* ♤ 연산자 오버로딩
	* ※ 연산자 오버로딩은 C++가 가진 다형 특성의 한 예이다.
	* ※ 연산자 오버로딩은 오버로딩의 개념을 연산자에까지 확장하여 C++ 연산자들에 다중적인 의미를 부여하는것이다.
	* EX) * 연산지는 주소에 저장되어 있는 값을 가져오기도 하지만 곱셈의 역할도 한다
	* ※ 연산자를 오버로딩하려면, 연산자 함수라는 특별한 함수를 사용 해야 한다.
	* operatorop(argument-list) (원형) -> 사용) operator*()
	* ※ 여기서 op는 오버로딩할 연산자를 나타내는 기호이다.
	* 
	↓ 오버로딩 제약
	* 1. 오버로딩된 연산자는, 적어도 하나의 피연산자가 사용자 정의 데이터형일 것을 요구한다.
	* 이 제약은 표준 데이터형을 위해서 사용되는 연산자들을 오버로딩하는 것을 막아 준다.
	* 그러므로 뺼셈 연산자를 두 개의 double형 값의 차가 아닌 합을 산출하도록 재정의할 수 없다.
	* 2. 오버로딩된 연산자를, 오리지널 연산자에 적용되는 문법 규칙을 위반하는 방식으로 사용할 수 없다. 마찬가지로 연산자 우선순위도 변경할 수 없다.
	* 3. 연산자 기호를 새로 만들 수 없다.
	* 4. 몇몇 연산자는 오버로딩할 수 없다. 721~722 페이지 참고
	* ※ 연산자 오버로딩을 사용할때는 신중해야 한다. 동작이 명확하지 않을때는 차라리 메서드를 정의하는게 바람직하다.
	* 
	* ♤ 프렌드
	* ※ 일반적으로 객체의 private 부분에 접근할 수 있는 유일한 통로는 public 클래스 메서드들이다.
	* ※ 함수를 어떤 클래스에 대해 프렌드로 만들면, 그 프렌드 함수는 클래스의 멤버 함수들이 가지는것과 동일한 접근 권한을 갖는다. [프렌드 함수, 프렌드 클래스, 프렌드 멤버 함수]
	* → 프렌드 생성
	* 클래스 선언에 friend 함수 원형을 넣어주면 끝
	* friend Time operator*(double m, const Time & t);
	* 1. operator*() 함수는, 클래스 선언 안에 선언되지만 멤버 함수가 아니다. 그러므로 멤버 연산자를 사용하여 호출되지 않는다.
	* 2. operator*() 함수는, 그것이 비록 멤버 함수는 아니지만 멤버 함수와 동등한 접근 권한을 가진다.
	* 함수 정의에는 friend를 쓸 필요가 없고 멤버 함수가 아니기 때문에 Time::을 쓸 필요도 없다.
	* 
	* → 프렌드 << 연산자의 오버로딩
	* trip이 time 클래스의 객체라고 가정하고 이때까지는 객체의 내용을 출력하기 위해서는 Show()를 사용했다.
	* cout <<  trip; 사용이 가능하다.
	* void operator<<(ostream & os, const Time & t)
	* { os << t.hours << "시간"; }
	* 이렇게 오버로딩하면 사용할 수 있다.
	* 단 문제점이라면 cout << "ㅁㄴㅇ" << trip; 이렇게 하면 작동하지 않는다.
	* cout << "ㅁㄴㅇ"를 처리하면 ostream 객체가 아니라서 << trip은 수행할 수 없다.
	* ostream & operator<<(ostream & os, const Time & t)
	* { 
	*		os << t.hours << "시간"; 
	*		return os;
	* }
	* 이렇게 하면 ostream 객체를 리턴해서 사용할 수 있다.
	* 
	* ♤ 오버로딩 연산자: 멤버 함수와 멤버가 아닌 함수
	* ※ 많은 연산자들에 대해서 연산자 오버로딩을 구현할 때, 멤버 함수로 구현할 것인지 멤버가 아닌 함수로 구현할 것인지를 선택해야 한다.
	* ※ 두 형식을 모두 정의하면 모호성 에러가 발생한다.
	* ※ 일부 연산자들에 대해서는 멤버 함수가 유일하고도 적절한 선택이다. 그 외에는 별차이가 없다.
	* ※ 클래스 설계에 따라서 간혹, 그 클래스에 대한 데이터형 반환을 정의했을 경우 멤버가 아닌 버전이 유리할 수도 있다.
	* 
	* ♤ 오버로딩 보충
	* 1. 상태 멤버 사용, bool 타입 변수로 객체의 상태를 나타냄
	* 2. 오버로딩된 연산자 또 오버로딩하기 (두번 오버로딩 한다는 의미가 아니라, 같은 부호로 다른 동작을하게 오버로딩을 두번 한다는 뜻)
	* 예를들어 - 연산자는 두 개의 피연산자에 사용되었을 때는 뺄셈 연산자이다. (이항 연산자)
	* -x와 같이 하나의 피연산자에 사용했을때는 마이너스 부호 연산자이다. (단한 연산자)
	* operator- ()에 대해 두개의 서로 다른 정의를 만들었다면, 두 개의 정이가 서로 다른 시그내처를 사용하므로 아무런 문제가 없다.
	* !! 단 / 나눗셈 연산자와 같이 이항 형식만을 사용하는 연산자는 이항 연산자로만 오버로딩할 수 있다.
	* 
	* ♤ 자동 변환과 클래스의 데이터형 변환
	* ♠ 변환 생성자
	* ※ Fraction(int num = 0, int den = 1)라는 생성자가 있고 void doSomething(Fraction frac)라는 메서드가 있다.
	* ※ doSomething(7);을 호출하면 에러가 발생해야 정상이지만 아무런 문제가 없다. doSomething(Fracion(7, 1)); 이나 마찬가지다.
	* ※ 객체를 인수로 받는데도 불구하고 int형인 7을 받아도 문제가 발생하지 않는다.
	* ※ 이는 컴파일러가 자동 형변환을 해주기 때문에 발생하는 특이 현상이며, 이런 현상이 생기는 생성자를 변환 생성자라고 한다.
	* ※ 7이 인수로 넘겨질 때 함수 내부의 매개변수 객체인 frac이 생성되면서 Fraction frac = 7
	* ※ 즉 Fraction(int num = 0, int den = 1) 생성자가 호출되어 Fraction 타입의 임시 객체가 만들었졌기 때문에 문제가 없는 것이다.
	* ※ 인수로 7 하나만 받았기 때문에 den 멤버는 디폴트 값은 1로 초기화되어 최종적으로 “Fracion(7, 1)”로 호출한 것이나 마찬가지인 Fraction 타입의 임시객체가 생성된다.
	* ※ 인수를 int 로 잘못 넘겼음에도 불구하고 컴파일러가 int 하나를 받는 생성자를 호출하여 Fraction 타입의 임시 객체로 자동 형변환 해준 셈.
	* ※ 위 생성자는 int 인수 하나만 들어오면 무조건 OK라 이런 문제가 발생함
	* 좋지 않은 점
	* 1. 논리성이 떨어진다.
	* 1-1. 특정 타입의 객체를 인수로 받는다고 명시했음에도 컴파일러가 자동 형변환을 해줘서 int로 넘겨도 문제가 없으니
	* 1-2. 실수로 int로 변환될 수 있는 char 같은 것들을 넘겨도 컴파일러가 자동 형변환을 해주므로 변환 생성자가 호출되는 문제가 발생한다.
	* 2. 메모리 낭비다.
	* 2-1 int로 넘겨도 변환 생성자를 호출하는 바람에 임시 객체를 생성하고 소멸화는 과정이 따르기 때문
	* 
	* ※ 자동 형변환을 하면 위와 같은 부작용을 일으킬 수 있어 자동 데이터형 변환을 못하게하는 explicit을 지원한다.
	* ※ 변환 생성자의 무작위 호출을 막고 명확성을 높여준다
	* explicit Fraction(int num = 0, int den = 1) // 위의 코드를 이렇게 수정할 수 있다.
	* explicit Test(double d) // 암시적 데이터 변환을 허용하지 않는다.
	* ※ 강제 형변환은 허용한다.
	* Test test;
	* test = 19.6; // Test(double)이 explicit로 선언되면 틀림
	* test = Test(19.6) // 명시적 데이터 변환으로 사용가능
	* test = (Test) 19.6 // 명시적 데이터형 변환의 옜날 형식
	* 
	* ↓ 또한 생성자에 delete 키워드를 붙여 특정 타입의 인수는 받지 않도록 막을 수 있다. 이때의 delete는 동적 할당 받은 메모리를 해제 시키는 delete와는 다르다.
	* public:
	*  Fraction(char) = delete;
	*		explicit Fraction(int num = 0, int den = 1)
	*		{
	*			assert(den != 0); 
	*		}
	* ※ 이렇게 하면 char 타입의 인수는 받지 않는다.
	* 
	* ↓ 변환 함수
	* ※ 클래스의 객체를 데이터형 값으로 변환할 수 있다.
	* Test test(11.2);
	* double d = test;
	* ※ 가능하다 그러나 생성자를 사용하지 않는다. 생성자는 어떤 데이터형을 클래스형으로 변환하는 것만 허용한다.
	* ※ 이 과정을 반대로 하기 위해서는 변환 함수라고 부르는  연산자 함수를 사용해야 한다.
	* ※ 변환 함수는 사용자 정의 강제 데이터형 변환이다.
	* ※ 따라서 일반적인 강제 데이터형 변환(type cast)처럼 사용하면 된다.
	* operator typename();
	* 1. 변환 함수는 클래스의 메서드여야 한다.
	* 2. 변환 함수는 리턴형을 가지면 안 된다.
	* 3.변환 함수는 매개변수를 가지면 안 된다.
	* 예를 들어 double형으로 변환하는 함수의 원형은 다음과 같다.
	* operator double();
	* 
	* ↓↓ 데이터형 변환의 자동 적용
	* ※ 변환 생성자와 마찬가지로 변환 함수도 좋은 점과 나쁜 점이 있다.
	* ※ 암시적 변환을 자동으로 수행하는 함수의 문제점은, 원하지 않을 때에도 그러한 변환을 수행할 수 있다는 것이다.
	* ※ C++11 부터는 변환 연산자를 exlicit 키워드로  선언하여 변환 연산자가 명시적임을 선언할 수 있다.
	* exlicit operator double() const; // 원형
	* exlicit operator int(); // 원형
	* int Test::
	* 
	* ※ C++는 클래스에 대해 다음과 같은 데이터형 변환 기능을 제공한다.
	* 1. 하나의 매개변수를 사용하는 클래스 생성자는, 그 매개변수의 데이터형을 클래스형으로 변환하는 명령어 역할을 한다.
	* 2. 변환 함수라고 부르는 특별한 클래스 멤버 연산자 함수는, 클래스 객체를 다른 어떤 데이터형으로 변환하는 명령어 역할을 한다.
	* 
	* ↓ 변환과 프렌드
	* ※ 예를들어 덧셈을 오버로딩하기 위해 멤버 함수를 사용할 수도 있고, 프렌드 함수를 사용할 수 있다.
	* Test Test::operator+(객체) const { }
	* Test operator+(객체1, 객체2) { }
	* Test t1(1,2);
	* Test t2(3,4);
	* Test total;
	* total = t1 + t2;
	* ※ 둘중에 하나라도 선언되어 있으면 위의 코드는 동작 가능하다.
	* total = t1.operator+(t2);
	* total = operator+(t1, t2); 로 실행을 하게 된다.
	* 
	* 하나의 매개변수가 실수이고 멤버 함수를 사용했을 경우 아래의 동작을 수행한다.
	* Test t1(1,2);
	* double d = 12.4;
	* Test total;
	* total = t1 + d; (객체 + 실수)
	* 그러나 아래와 같은 코드는 프렌드 함수만 수행할 수 있다.
	* Test t1(1,2);
	* double d = 12.4;
	* Test total;
	* total = d + t1; (실수 + 객체)
	* 위 코드를 풀어보면
	* total = t1.operator+(d); (멤버함수)
	* total = operator+(d, t1); (프렌드)
	* 위와 같은 차이점이 있다.
	* 
	* 그런데 여기다 operator double() 멤버 함수를 정의하면, 또 하나의 해석이 가능해져 이 시점에서 혼동을 일으킬수있다.
	* double d를 double형으로 변환하여 덧셈을 수행하는 대신 t1을 double 형으로 변환하여 덧셈을 수행할 수 있게되버린다. 이처럼 변환 함수가 너무 많으면 상황이 모호해진다.
	* 
	* operator double() 멤버 함수가 있다는 가정하에
	* total = d + t1;은 total = operator(d, t1); // 프렌드 함수
	* 처럼 된다. t1, d 모두 double 형이라서 생성자(double)을 호출하여 클래스 객체로 변환된다.
	* (책 내용에는 double을 매개변수로 하는 생성자가 있음, 컴파일러가 t1을 double형으로 자동 변환을 해버림)
	* 덧셉을 프렌드로 정의하는 것은, 프로그램이 자동 데이터형 변환을 더 쉽게 처리할 수 있도록 만든다.
	* 왜냐하면 두 피연산자 모두 함수의 매개변수가 되고, 함수 원형이 두 피연산자에 대해 모두 올바른 역할을 하기 때문이다.
	* 
	* !! 객체라고 적어서 방금 헷갈렸는데 책 내용 잘보면 객체를 더하는게 아니라 operator+로 값을 더하는 코드가 구현되있음
	* ♤ 덧셈 구현의 선택
	* double형 값을 객체형 값에 더하기를 원한다면, 할 수 있는 선택지는 두 가지이다.
	* 1. operator+(const 객채 &, const 객체 &)를 프렌드 함수로 정의하고 객체(double) 생성자를 사용하여 double형 매개변수를 객체형 매개변수로 변환하는 것이다
	* 2. gkskdml double형 매개변수를 명시적으로 사용하는 함수들로 덧셈 연산자를 한 번 더 오버로딩하는 것이다.
	* Test operator+(double x);
	* friend Test operator+(double x, Test & s);
	* 
	* 첫 번째 선택은 함수를 더 적게 정의하므로 프로그램이 짧아진다.
	* 또한 프로그래머가 할 일이 적어지므로 뒤죽박죽해질 위험성이 적다.
	* 단점은 메모리에 추가 부담이 있고, 시간이 더 걸린다.
	* 두 번째 선택은 프로그램이 길어지지만 실행 속도가 빠르다.
	* 덧셈을 자주 한다면 오버로딩하는 것이 좋고 드물게 사용한다면 자동 변환에 의존하는 것이 간단하다.
	* 다만, 암시적 변환 함수는 되도록 사용하지 않는 것이 바람직하고 클래스의 사용은 단순한 C 스타일의 구조체보다 더 많은 주의를 요한다.
	*/
}