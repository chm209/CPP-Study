#include <iostream>

void main(void)
{
	// ◆ 클래스의 상속
	// 1. 객체 지향 프로그래밍의 중요한 목적 중 하나. 코드의 재활용
	// 2. C++는 클래스를 확장하고 수정하기 위해 클래스 상속을 제공한다.
	// 3. 기초 클래스라 부르는 클래스로부터 모든 메서드와 멤버들을 상속 받아 새로운 파생 클래스를 만든다.
	// 4. 기존의 클래스에 기능을 추가할 수 있다.
	// 5. 클래스가 나타내고 있는 데이터에 다른 것을 더 추가할 수 있다.
	// 6. 클래스 메서드가 동작하는 방식을 변경할 수 있다.

	// 간단한 기초 클래스부터 시작하자

	/*
	* 기초 클래스: 어떤 클래스를 다른 클래스로부터 상속할때, 오리지널 클래스
	* 파생 클래스: 상속 받는 클래스
	* 
	* 896페이지 예제.
	* ※ C 스타일 string 구문으로 된 생성자를 사용한다.
	* TableTennisPlayer p1("asd", "asd", true);
	* ※ 그러나 생성자 선언에서 매개변수들의 타입은 const string & 형이다
	* ※ 잘못 연결된 자료형이지만, 표준 string 클래스는 const char* 형의 매개변수를 지닌 생성자를 가지고 있다.
	* ※ 그리고 이 생성자는 C 스타일 string 으로 초기화된 string 객체를 생성하기 위해 자동으로 사용된다.
	*
	* ● 클래스 파생시키기
	* ※ RatedPlayer는 TableTennisPlayer 기초 클래스로부터 파생된다.
	* class RatedPlayer : public TableTennisPlayer { ... };
	* ※ 이 표제는 TableTennisPlayer가 public 기초 클래스라는 것을 나타낸다.
	* 1. 이것을 public 파생이라고 한다.
	* 2. 파생 클래스의 객체는 기초 클래스의 객체를 합병한다.
	* 3. public 파생에서는 기초 클래스의 public 멤버들이 파생 클래스의 public 멤버가 된다.
	* 4. 기초 클래스의 private 부분들도 파생 클래스의 일부가 된다.
	* 5. 그러나 그들은 기초 클래스의 protected 메서드와 public 메서드를 통해서만 접근할 수 있다.
	* 
	* ↓ 무엇을 할 수 있을까
	* ※ RatedPlayer 객체를 선언한다면, 그 객체는 다음과 같은 특별한 속성을 가진다.
	* 1. 파생 클래스형의 객체 안에는 기초 클래스형의 데이터 멤버들이 저장된다. (기초 클래스의 구현들을 상속 받는다.)
	* 2. 파생 클래스형의 객체는 기초 클래스형의 메서드들을 사용할 수 있다.
	* 
	* ↓ 상속받는 기능에 무엇을 추가할 필요가 있을까
	* 1. 파생 클래스는 자기 자신의 생성자를 필요로 한다.
	* 2. 파생 클래스는 부가적인 데이터 멤버들과 멤버 함수들을 필요한 만큼 추가할 수 있다.
	* 
	* ● 생성자: 접근에 대하여
	* ※ 파생 클래스는 기초 클래스의 private 멤버에 직접 접근할 수 없다. 기초 클래스의 메서드들을 통해서 접근해야 한다.
	* 1. 프로그램이 파생 클래스의 객체를 생성할 때, 먼저 기초 클래스의 객체를 생성한다.
	* 파생 클래스 생성자의 몸체 안으로 들어가기 전에, 기초 클래스 객체가 먼저 생성되어야 한다는 것을 의마한다.
	* C++는 이것을 하기 위해 멤버 초기자 리스트 문법을 사용한다.
	* RatedPlayer::RatedPlayer(unsigned int r, const char * fn, const string & ln, bool ht) : TableTennisPlayer(fn, ln, ht)
	* { rating = r; }
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	* 
	*/
}