#include <iostream>
void ex01(void);

void main()
{
	// C++ 코드의 재활용
	// ※ C++가 추구하는 중요한 목표 중의 하나가 코드의 재활용성을 높이는것
	// public 상속은 한 가지 방법일뿐, 다른 방법들도 존재한다.
	// ◈ 한가지 테그닉은 다른 클래스에 속하는 객체를클래스 멤버로 사용하는것.
	// 이것을 컨테인먼트, 컴포지션 또는 레이어링이라 부른다.
	// 
	// ◈ 또 한가지 테크닉은 private 상속이나 protected 상속을 사용하는 것
	// 
	// ◈ '객체와 클래스' 에서 함수 템플릿을 공부했다. 이번에는 클래스 템플릿에 대해서 공부한다.
	// ※ 클래스 템플릿을 사용하면 클래스를 포괄적으로 정의할 수 있다.
	// 그리고 나서 그 템플릿을 사용하여, 특정한 데이터형에 맞게 정의된 특정한 클래스를 생성할 수 있다.
	ex01();
}

void ex01(void)
{
	// 객체 멤버를 가지는 클래스
	// ※ 예제 클래스를 만들어보면서 공부

	/*
	* ※ 템플릿 클래스를 어떻게 정의하는지는 나중에 배우고 우선 사용 방법을 배운다.
	* 템플릿 측면에서 보면, 객체를 선언할 때 구체적인 데이터형을 지정해야 한다.
	* 그렇게 하려면, 객체를 선언할 때 원하는 데이터형이 들어 있는 각괄호(<>) 앞에 식별자 valarray를 붙여야 한다.
	* valarray<int> q_values; // int형의 배열
	* valarray<double> weight; // double형의 배열
	* ※ 이러한 구문을 vector와 array를 공부하면서 봤다.
	* ※ 이러한 템플릿 클래스는 숫자를 지닐 수 있지만 valarray 클래스가 하는 것처럼 모든 사칙연산을 지원하지 않는다.
	* 
	* ※ C++에서 has-a 관계를 모델링하는 일반적인 테크닉은 컴포지션(컨테인먼트)을 사용하는 것이다.
	* 즉, 다른 클래스의 객체들을 멤버로 가지는 클래스를 만드는 것이다.
	* 
	* ※ 인터페이스와 구현
	* public 상속에서, 클래스는 인터페이스와 구현을 상속한다. 인터페이스를 획득하는 것은 is-a 관계의 역할이다.
	* 반면에 컨테인먼트에서는 어떤 클래스가 인터페이스 없이 구현을 획득한다. 인터페이스를 상속하지 않는 것이 has-a 관계의 역할이다.
	* 
	*/
}