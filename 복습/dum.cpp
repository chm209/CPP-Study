// 잔디밭 보면 알겠지만 (노트북 고장 + 맥 설정 + 솔직히 놀았음) 때문에 대부분 까먹었다.
// 챕터8부터 복습한다고 생각하고 빠르게 훑어보고 원래 진도로 나가겠음
// 시작: 09-12-2021

#include <iostream>

int main(void)
{
    // ======================================================== //
    // 챕터8 메모리 모델과 이름공간
    // 코드 위치에 따라 메모리 존속 시간이 다른것 복습
    // 제한자 키워드 mutable 가급적 사용하지 말것
    // volatile 키워드도 많이 사용하면 성능 하락, 임베디드군에서만 컴파일러 최적화를 위해 사용함
    // new 연산자로 초기화 -> 동적 메모리 대입
    // 위치지정 new 연산자 -> 메모리를 힙에 둘지 변수 공간에 둘지 정하는거임 사용방법은 new랑 같고 600페이지 참조
    // 위치지정 new 사용할거면 위치지정 delete도 준비해야함
    // using 선언자 지시자 차이 확인
    //
    // 아래 변수 3개 다 다름
    // using namespace chm209;
	// int t; // cjm209::t를 가린다.
	// t 지역
	// ::t 전역
	// chm::t chm의 변수
    // 하지만 지금 이름처럼 하면 모호해서 에러남
    // namespace 중첩과 이름 없는 네임스페이스가 전역처럼 동작하는거 확인
    // 네임스페이스 가이드라인 확인

    // ======================================================== //
    // 챕터9 객체와 클래스
    // oop 기초 확인
    // 클래스 선언, 메서드 정의 확인
    // 접근제어 확인
    // 생성자, 소멸자 확인 -> new로 메모리 대입하면 무조건 소멸해줘야함
    // const 멤버 함수 확인 -> 코드를 수정하지 않는다는 보장을 하기 위해 함수 선언과 정의에 const를 추가한다.
    // this 포인터 확인 -> 하나의 메서드가 두 개의 객체를 동시에 처리할 때 사용, this는 그 객체의 주소
    // 멤버함수 체이닝 기법 확인
    // 클래스 사용 범위 상수 확인 -> 예제 코드는 클래스 선언 부분이라서 에러나는거임
    // enum을 사용하는 방법 확인
    // static을 사용하는 방법 확인
    // 범위가 정해진 열거법 확인
    // 추상화, 캡슐화 개념 확인

    // ======================================================== //
    // 챕터10 클래스의 활용
    // 연산자 오버로딩 & 오버로딩 제약 확인
    // 프렌드 개념 확인 & 프랜드 << 연산자 확인
    // 오버로딩 연산자: 멤버 함수와 멤버가 아닌 함수 확인
    // 오버로딩 보충 내용 확인
    // 자동 변환과 클래스의 데이터형 변환 확인
    // 변환 생산자 확인 -> 논리성 떨어지고, 메모리 낭비, 실수하기 쉽다
    // 자동 형변환을 방지하는 explicit 사용 방법 확인
    // 변환 함수 & 데이터 암시적, exlicit 사용으로 명시적 변환 확인
    // 변환과 프렌드 확인

    // ======================================================== //
    // 챕터11 클래스와 동적 메모리 대입 복습
    // 특별 멤버 함수 확인
    // ㄴ 암시적, 명시적 디폴트 생성자 확인
    // ㄴ 얕은 복사, 깊은 복사, 복사 생성자 확인
    // ㄴ 생성자에 new를 사용할때 주의할 점 확인
    // 객체 리턴, const 객체 리턴 확인
    // new에 의한 객체 초기화 학인
    // 객체를 지시하는 포인터 확인
    // 위치지정 new 확인
    // 각종 테크닉, 멤버 초기자 리스트 확인

    // ======================================================== //
    // 챕터12 클래스의 상속 복습
    // 기초 클래스, 파생 클래스 개념 확인
    // public 파생 확인
    // ㄴ 파생 클래스 & 기초 클래스 생성자 관련 확인
    // 파생 클래스와 기초 클래스의 관계 확인
    // 가상 함수 사용 & 주의사항 확인
    // 정적 결합 동적 결합 확인
    // 포인터와 참조형의 호환 확인
    // ㄴ 업캐스팅, 다운캐스팅 확인
    // 가상 멤버 함수와 동적 결합 확인
    // 가상 함수 동작 확인 - 컴파일러 동작 확인
    // protected 동작과 위험성 확인
    // 추상화 기초 클레스 확인
    // ㄴ 순수 가상 함수 -> =0 붙는거 확인
    // ㄴ 추상화 클래스는 순수 가상 함수가 하나 이상인것
    // ㄴ 순수 가상 함수로만 이루어진 추상화 클래스를 인터페이스라고 함
    // ㄴ "대충 이런일은 할 건데 이 행동은 파생 클래스마다 다를 거니까 설계만 해놓았어. 실제 정의(구현)는 파생 클래스에서 해야 해"가 추상화 기초 클래스
    // 상속과 동적 메모리 대입 확인
}